<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Veng的博客</title>
  <icon>https://www.gravatar.com/avatar/a702d1d18bfed739de497f030ce2648c</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://veng.gitee.io/hexo/"/>
  <updated>2022-08-19T06:04:16.584Z</updated>
  <id>http://veng.gitee.io/hexo/</id>
  
  <author>
    <name>Veng</name>
    <email>veng0923@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iptables</title>
    <link href="http://veng.gitee.io/hexo/2022/08/19/iptables/"/>
    <id>http://veng.gitee.io/hexo/2022/08/19/iptables/</id>
    <published>2022-08-19T03:53:27.000Z</published>
    <updated>2022-08-19T06:04:16.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-iptables-命令基本语法"><a href="#1-iptables-命令基本语法" class="headerlink" title="1. iptables 命令基本语法"></a>1. iptables 命令基本语法</h2><blockquote><p>“iptables [-t table] command [链名] [条件匹配] [-j 目标动作]</p></blockquote><p><img src="https://veng-photo.oss-cn-beijing.aliyuncs.com/jd6utdfije.png" alt="img"></p><p><strong>以下是对 iptables 命令的拆分讲解：</strong></p><a id="more"></a><h3 id="1-2-t-table"><a href="#1-2-t-table" class="headerlink" title="1.2 -t table"></a>1.2 -t table</h3><p>用来指明使用的表，有三种选项: <code>filter</code>，<code>nat</code>，<code>mangle</code>。若未指定，则<strong>默认使用filter表</strong>。</p><h3 id="1-3-command参数"><a href="#1-3-command参数" class="headerlink" title="1.3 command参数"></a>1.3 command参数</h3><p>指定iptables 对我们提交的规则要做什么样的操作，以下是command常用参数：</p><ul><li><strong><code>-A</code></strong></li></ul><p>Append，追加一条规则（放到最后）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">举例：iptables -A INPUT -j DROP #拒绝所有人访问服务器（作为最后一条规则）</span><br><span class="line"><span class="comment">// 若未 -t 指定表，默认使用filter表</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>-I</code></strong></li></ul><p>Insert，在指定的位置插入规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 举例：iptables -I INPUT 2 -s 10.10.10.1 -j ACCEPT #允许10.10.10.1主机访问本机</span><br><span class="line"><span class="comment">// 在 filter 表的 INPUT 链插入成第2条规则</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>-L</code></strong></li></ul><p>List，查看规则列表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 具体参数：n：只显示 IP 地址和端口号码，不显示域名和服务名称</span><br><span class="line">v：显示详细信息，包括每条规则的匹配包数量和匹配字节数</span><br><span class="line">x：在 v 的基础上，禁止自动单位换算（K、M）</span><br><span class="line">--line-number：可以查看到规则号</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举例：iptables -nL --line-number</span><br></pre></td></tr></table></figure><p><img src="https://ask.qcloudimg.com/raw/yehe-b344c32fabf35/p31lofs9ek.png?imageView2/2/w/1620" alt="img"></p><ul><li><strong><code>-D</code></strong></li></ul><p>Delete，从规则列表中删除规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 举例：iptables -D INPUT <span class="number">2</span></span><br><span class="line"><span class="comment">// 删除 filter 表 INPUT 链中的第 2 条规则</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>-P</code></strong></li></ul><p>Policy，设置某个链的默认规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">举例：iptables -P INPUT DROP</span><br><span class="line"><span class="comment">// 设置 filter 表 INPUT 链的默认规则是 DROP</span></span><br></pre></td></tr></table></figure><blockquote><p>“当数据包没有被任何规则匹配时，则按默认规则处理。</p></blockquote><ul><li><strong><code>-F</code></strong></li></ul><p>Flush，清空规则</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  举例：</span><br><span class="line">iptables -F INPUT #清空filter 表中INPUT链上的规则</span><br><span class="line">iptables -F #清空filter 表中所有链上的规则</span><br><span class="line">iptables -t nat -F PREROUTING ##清空NAT表中PREROUTING链上的规则</span><br><span class="line">iptables -t nat -F #清空NAT表中所有链上的规则</span><br></pre></td></tr></table></figure><blockquote><p>“注意：-F 是清空链中规则，但并不影响 -P 设置的默认规则。<strong>因此在生产环境中，若指定默认规则为DROP，一旦执行<code>iptables -F</code>，很容易导致自己也无法连接</strong><a href="https://cloud.tencent.com/product/cvm?from=10680" target="_blank" rel="noopener"><strong>服务器</strong></a><strong>（-F 会把配置的明细ACCEPT规则删除，只留下默认规则拒接所有）。</strong></p></blockquote><ul><li><strong><code>-Z</code></strong></li></ul><p>zero，将指定链的所有计数器归零。（如未指定，则认为是所有链）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">iptables -Z INPUT</span><br><span class="line"><span class="comment">//清除filter表INPUT链上的计数器</span></span><br></pre></td></tr></table></figure><h3 id="1-4-条件匹配参数"><a href="#1-4-条件匹配参数" class="headerlink" title="1.4 条件匹配参数"></a>1.4 条件匹配参数</h3><h4 id="1-4-1-按网络接口匹配"><a href="#1-4-1-按网络接口匹配" class="headerlink" title="1.4.1 按网络接口匹配"></a>1.4.1 按网络接口匹配</h4><ul><li><strong><code>-i</code></strong></li></ul><p>匹配数据进入的网络接口，此参数主要应用nat表，例如目标地址转换。</p><ul><li><strong><code>-o</code></strong></li></ul><p>匹配数据流出的网络接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">-i eth0</span><br><span class="line"><span class="comment">// 匹配从网络接口eth0进来的数据包</span></span><br><span class="line"></span><br><span class="line">-o eth1</span><br><span class="line"><span class="comment">// 匹配从eth1流出的数据包</span></span><br></pre></td></tr></table></figure><h4 id="1-4-2-按源及目的地址匹配"><a href="#1-4-2-按源及目的地址匹配" class="headerlink" title="1.4.2 按源及目的地址匹配"></a>1.4.2 按源及目的地址匹配</h4><ul><li><strong><code>-s</code></strong></li></ul><p>匹配源地址，可以是IP、网段、<a href="https://cloud.tencent.com/act/pro/domain-sales?from=10680" target="_blank" rel="noopener">域名</a>，也可空（代表任何地址）</p><ul><li><strong><code>-d</code></strong></li></ul><p>匹配目标地址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">-s 参数举例：</span><br><span class="line">iptables -A INPUT -s <span class="number">10.10</span><span class="number">.10</span><span class="number">.10</span> -j DROP</span><br><span class="line"><span class="comment">// 拒绝10.10.10.10主机访问本机</span></span><br><span class="line"></span><br><span class="line">-d 参数举例：</span><br><span class="line">iptables -A OUTPUT -d www.baidu.com -j DROP</span><br><span class="line"><span class="comment">// 禁止本机访问百度</span></span><br></pre></td></tr></table></figure><h4 id="1-4-3-按协议类型匹配"><a href="#1-4-3-按协议类型匹配" class="headerlink" title="1.4.3 按协议类型匹配"></a>1.4.3 按协议类型匹配</h4><ul><li><strong><code>-p</code></strong></li></ul><p>匹配协议类型，可以是TCP、UDP、ICMP等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  举例：</span><br><span class="line">iptables -A INPUT -s <span class="number">10.10</span><span class="number">.10</span><span class="number">.10</span> -p icmp -j DROP</span><br><span class="line"><span class="comment">// 禁止10.10.10.10主机ping通本机</span></span><br></pre></td></tr></table></figure><h4 id="1-4-4-按源及目的端口匹配"><a href="#1-4-4-按源及目的端口匹配" class="headerlink" title="1.4.4 按源及目的端口匹配"></a>1.4.4 按源及目的端口匹配</h4><ul><li><strong><code>--sport</code></strong></li></ul><p>匹配源端口;可以是单个端口，也可以是端口范围</p><ul><li><strong><code>--dport</code></strong></li></ul><p>匹配目的端口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">-- sport <span class="number">23</span></span><br><span class="line"><span class="comment">//匹配源端口是23的数据包</span></span><br><span class="line"></span><br><span class="line"> -- sport <span class="number">2000</span>:<span class="number">3000</span></span><br><span class="line"><span class="comment">//匹配源端口是 2000-3000 的数据包</span></span><br><span class="line"></span><br><span class="line">-- sport :<span class="number">2000</span></span><br><span class="line"><span class="comment">//匹配2000以下的数据包（包含2000）</span></span><br><span class="line"></span><br><span class="line">- --sport <span class="number">1000</span>:</span><br><span class="line"><span class="comment">//匹配1000以上的数据包（包含1000）</span></span><br></pre></td></tr></table></figure><blockquote><p>“注意：–sport 和 –dport 必须配合 -p 参数使用，例如：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp –dport <span class="number">80</span> -j ACCEPT</span><br><span class="line"><span class="comment">//允许外部数据访问我的本地服务器80端口</span></span><br><span class="line"></span><br><span class="line">详细解释：</span><br><span class="line"><span class="number">1</span>、这是一条从外部进入内部本地服务器的数据</span><br><span class="line"><span class="number">2</span>、数据包的目的（dport）地址是<span class="number">22</span>，就是要访问我本地的<span class="number">22</span>端口</span><br><span class="line"><span class="number">3</span>、允许以上的数据行为通过</span><br></pre></td></tr></table></figure><h3 id="1-5-目的动作"><a href="#1-5-目的动作" class="headerlink" title="1.5 目的动作"></a>1.5 目的动作</h3><ul><li><strong><code>-j ACCEPT</code></strong></li></ul><p>允许数据包通过本链而不拦截它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">iptables -A INPUT -j ACCEPT</span><br><span class="line"><span class="comment">// 允许所有访问本机的数据包通过</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>-j DROP</code></strong></li></ul><p>丢弃数据包；阻止数据包通过本链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">iptables -A FORWARD -s <span class="number">10.10</span><span class="number">.10</span><span class="number">.10</span> -j DROP</span><br><span class="line"><span class="comment">// 阻止来自10.10.10.10 的数据包通过本机</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>-j SNAT</code></strong></li></ul><p>源地址转换，支持转换为单IP，也支持转换到IP地址池</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">转换到单IP举例：</span><br><span class="line">iptables -t nat -A POSTROUTING -s <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span> -j SNAT --to <span class="number">18.18</span><span class="number">.18</span><span class="number">.18</span></span><br><span class="line"><span class="comment">// 将内网 192.168.1.0/24 转换为公网18.18.18.18地址；SNAT，用于访问互联网</span></span><br><span class="line"></span><br><span class="line">转换到一组地址池：</span><br><span class="line">iptables -t nat -A POSTROUTING -s <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span> -j SNAT --to <span class="number">18.18</span><span class="number">.18</span><span class="number">.18</span><span class="number">-18.18</span><span class="number">.18</span><span class="number">.28</span></span><br><span class="line"><span class="comment">//同上，只不过是转换到一组IP地址池</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>-j DNAT</code></strong></li></ul><p>目的地址转换，支持转换为单IP，也支持转换到IP地址池</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">转换到单IP举例：</span><br><span class="line">iptables -t nat -A PREROUTING -i eth0 -p tcp --dport <span class="number">80</span> -j DNAT --to <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"><span class="comment">//把从eth0口进来访问TCP/80端口的数据包目的地址改成192.168.1.1</span></span><br><span class="line"></span><br><span class="line">转换到一组地址池：</span><br><span class="line">iptables -t nat -A PREROUTING -i eth0 -p tcp --dport <span class="number">80</span> -j DNAT --to <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span><span class="number">-192.168</span><span class="number">.1</span><span class="number">.10</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>-j MASQUERADE</code></strong></li></ul><p>动态SNAT转换（适用于动态 IP 场景 ）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">iptables -t nat -A POSTROUTING -s <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span> -o eth0 -j MASQUERADE</span><br><span class="line"><span class="comment">// 将源地址是 192.168.1.0/24 的数据包进行地址伪装，转换成 eth0 上的 IP 地址</span></span><br></pre></td></tr></table></figure><h2 id="2-iptables-常用附加模块"><a href="#2-iptables-常用附加模块" class="headerlink" title="2.iptables 常用附加模块"></a>2.iptables 常用附加模块</h2><h3 id="2-1-按包状态匹配-（state）"><a href="#2-1-按包状态匹配-（state）" class="headerlink" title="2.1 按包状态匹配 （state）"></a>2.1 按包状态匹配 （state）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-m state --state 状态</span><br><span class="line">举例：</span><br><span class="line">iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">&#x2F;&#x2F; 将目前已运行的服务端口全部放行！无风险，良心推荐使用</span><br></pre></td></tr></table></figure><h3 id="2-2按来源-MAC-匹配（mac）"><a href="#2-2按来源-MAC-匹配（mac）" class="headerlink" title="2.2按来源 MAC 匹配（mac）"></a>2.2按来源 MAC 匹配（mac）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-m mac --mac-source MAC</span><br><span class="line">举例：</span><br><span class="line">iptables -A INPUT -m mac --mac-source xx:xx:xx:xx:xx:xx -j DROP</span><br><span class="line">&#x2F;&#x2F; 拒绝来自某 MAC 地址的数据包进入本机</span><br></pre></td></tr></table></figure><h3 id="2-3-按包速率匹配-（limit）"><a href="#2-3-按包速率匹配-（limit）" class="headerlink" title="2.3 按包速率匹配 （limit）"></a>2.3 按包速率匹配 （limit）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-m limit --limit 匹配速率</span><br><span class="line">  举例：</span><br><span class="line">iptables -A FORWARD -d 192.168.1.1 -m limit --limit 50&#x2F;s -j ACCEPT</span><br><span class="line">iptables -A FORWARD -d 192.168.1.1 -j DROP</span><br></pre></td></tr></table></figure><blockquote><p>“limit 英语上看是限制的意思，但实际上只是<strong>按一定速率去匹配</strong>而已，50/s 表示 1 秒中转发 50 个数据包，要想限制的话后面要再跟一条DROP规则</p></blockquote><h3 id="2-4-多端口匹配-（multiport）"><a href="#2-4-多端口匹配-（multiport）" class="headerlink" title="2.4 多端口匹配 （multiport）"></a>2.4 多端口匹配 （multiport）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-m multiport &lt;--sports|--dports|--ports&gt; 端口 1[,端口 2,..,端口 n]</span><br><span class="line">举例：</span><br><span class="line">iptables -A INPUT -p tcp -m multiport --dports 22,53,80,443 -j ACCEPT</span><br><span class="line">&#x2F;&#x2F; 允许访问本机TCP&#x2F;22,53,80,443端口</span><br></pre></td></tr></table></figure><blockquote><p>“注意：该参数必须与 -p 参数一起使用</p></blockquote><h2 id="3-iptables-规则备份和恢复"><a href="#3-iptables-规则备份和恢复" class="headerlink" title="3. iptables 规则备份和恢复"></a>3. iptables 规则备份和恢复</h2><blockquote><p>“我们执行 iptables 命令时，规则只是保存在内存中，并没有保存到某一个文件中。因此系统重启之后，之前设定的规则就没有了，所以规则设定完毕，检查无误后要及时保存规则，使用命令：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@LB-01 ~]# service iptables save</span><br><span class="line">iptables: Saving firewall rules to /etc/sysconfig/iptables:[  OK  ]</span><br></pre></td></tr></table></figure><p>会看到提示，防火墙规则保存在<code>/etc/sysconfig/iptables</code>文件内，这个文件就是iptables的配置文件。所以如果要备份防火墙规则，复制该配置文件即可。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/sysconfig/iptables /opt/myipt.rule</span><br></pre></td></tr></table></figure><p>如果需要恢复这些规则，使用以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables-restore &lt; <span class="regexp">/opt/myi</span>pt.rule</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-iptables-命令基本语法&quot;&gt;&lt;a href=&quot;#1-iptables-命令基本语法&quot; class=&quot;headerlink&quot; title=&quot;1. iptables 命令基本语法&quot;&gt;&lt;/a&gt;1. iptables 命令基本语法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;“iptables [-t table] command [链名] [条件匹配] [-j 目标动作]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://veng-photo.oss-cn-beijing.aliyuncs.com/jd6utdfije.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是对 iptables 命令的拆分讲解：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://veng.gitee.io/hexo/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="linux" scheme="http://veng.gitee.io/hexo/tags/linux/"/>
    
      <category term="嵌入式" scheme="http://veng.gitee.io/hexo/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="iptables" scheme="http://veng.gitee.io/hexo/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>pjlib-内存池-计时器解析</title>
    <link href="http://veng.gitee.io/hexo/2020/09/02/pjlib-%E5%86%85%E5%AD%98%E6%B1%A0-%E8%AE%A1%E6%97%B6%E5%99%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://veng.gitee.io/hexo/2020/09/02/pjlib-%E5%86%85%E5%AD%98%E6%B1%A0-%E8%AE%A1%E6%97%B6%E5%99%A8%E8%A7%A3%E6%9E%90/</id>
    <published>2020-09-02T01:57:17.000Z</published>
    <updated>2020-12-08T05:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>PJSIP是一个开放源代码的SIP协议栈。它支持多种SIP的扩展功能，目前可说算是最流行的sip协议栈之一了。</p><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><ul><li>PJSIP - Open Source SIP Stack[开源的SIP协议栈]</li><li>PJMEDIA - Open Source Media Stack[开源的媒体栈]</li><li>PJNATH - Open Source NAT Traversal Helper Library[开源的NAT-T辅助库]</li><li>PJLIB-UTIL - Auxiliary Library[辅助工具库]</li><li>PJLIB - Ultra Portable Base Framework Library[基础框架库]<a id="more"></a></li></ul><h2 id="PJLIB"><a href="#PJLIB" class="headerlink" title="PJLIB"></a>PJLIB</h2><p>要理解好PJSIP，就不得不先说说PJLIB，PJLIB算的上是这个库中最基础的库，正是这个<br>库的优美实现，才让PJSIP变得如此优越。</p><p>运行的平台有：</p><ul><li>Win32/x86 (Win95/98/ME, NT/2000/XP/2003, mingw).</li><li>arm, WinCE and Windows Mobile.</li><li>Linux/x86, (user mode and as <strong>kernel module</strong>(!)).</li><li>Linux/alpha</li><li>Solaris/ultra.</li><li>MacOS X/powerpc</li><li>RTEMS (x86 and powerpc).</li></ul><p>PJLIB提供了一系列特征，涉及到：</p><ul><li><p><code>非动态内存分配[No Dynamic Memory Allocations]</code></p><p>实现了内存池，获取内存是从与分配的内存池中获取，高性能程序多会自己构造内存池<br>，后面我们会解释该内存池的使用以及基本的原理。根据作者的比较，是常规的 malloc(<br>)/free()函数的30倍。</p></li><li><p><code>OS抽象[Operating System Abstraction]</code></p><ul><li>线程[Threads.]</li><li>线程本地存储[Thread Local Storage.]</li><li>互斥[Mutexes.]</li><li>信号灯[Semaphores.]</li><li>原子变量[Atomic Variables.]</li><li>临届区[Critical sections.]</li><li>锁对象[Lock Objects.]</li><li>事件对象[Event Object.]</li><li>时间管理[Time Data Type and Manipulation.]</li><li>高解析的时间戳[High Resolution Timestamp.]</li></ul></li><li><p><code>低层的网络相关IO[Low-Level Network I/O]</code></p><ul><li>Socket抽象[Socket Abstraction.]</li><li>网络地址解析[Network Address Resolution.]</li><li>实现针对Socket的select API[Socket select() API.]</li></ul></li><li><p><code>时间管理[Timer Management]</code></p><p>这主要涉及到两个部分，一个时定时器的管理，还有就是时间解析的精度(举例说来，就是能精确到哪个时间等级，比如 POSIX sleep(),就只能以秒为单位，而使用select()则可以实现毫秒级别的计时)</p></li><li><p><code>各种数据结构[Various Data Structures</code>]</p><ul><li>针对字符串的操作[String Operations]</li><li>数组辅助[Array helper]</li><li>Hash表[Hash Tabl]</li><li>链表[Linked List]</li><li>红黑平衡树[Red/Black Balanced Tree]</li></ul></li><li><p>异常处理[Exception Construct]</p></li><li><p>LOG机制[Logging Facility]</p></li><li><p>随机数以及GUID的产生[Random and GUID Generation]</p></li></ul><h2 id="内存池模块"><a href="#内存池模块" class="headerlink" title="内存池模块"></a>内存池模块</h2><p>没有动态分配内存，PJLIB的中心思想是，为了使应用程序尽可能快地运行，它根本不应该使用<em>malloc（）</em>，而应该从预分配的存储池中获取内存。使用此方法可以优化的一些：</p><ul><li>复杂度[<em>alloc()</em> is a O(1) operation.]</li><li>no mutex is used inside alloc(). It is assumed that synchronization will be used in higher abstraction by application anyway.</li><li>no <em>free()</em> is required. All chunks will be deleted when the pool is destroyed.</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>pj_init()</td><td>初始化PJ库。在使用库之前，必须先调用此函数。此函数的目的是初始化静态库数据（例如用于随机字符串生成的字符表），以及初始化依赖于操作系统的功能（例如Windows中的WSAStartup（））。</td></tr><tr><td>pj_caching_pool_init()</td><td>Create the pool factory.创建池工厂</td></tr><tr><td>pj_caching_pool_destroy()</td><td>destroy caching pool.销毁缓存池</td></tr><tr><td>pj_pool_create()</td><td>Must create pool before we can allocate anything.必须创建池在我们分配前</td></tr><tr><td>pj_pool_release()</td><td>释放池内存</td></tr><tr><td>pj_pool_alloc()</td><td>allocate some memory chunks,分配内存</td></tr></tbody></table><h3 id="源代码解析"><a href="#源代码解析" class="headerlink" title="源代码解析"></a>源代码解析</h3><p>首先是几个结构体的介绍：</p><h4 id="struct-pj-pool-t"><a href="#struct-pj-pool-t" class="headerlink" title="struct pj_pool_t"></a>struct pj_pool_t</h4><p>内存池的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This structure describes the memory pool. Only implementors of pool factory</span></span><br><span class="line"><span class="comment"> * need to care about the contents of this structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pj_pool_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PJ_DECL_LIST_MEMBER(struct <span class="keyword">pj_pool_t</span>);  <span class="comment">/**&lt; Standard list elements.    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Pool name */</span></span><br><span class="line">    <span class="keyword">char</span>    obj_name[PJ_MAX_OBJ_NAME];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Pool factory. */</span></span><br><span class="line">    pj_pool_factory *factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Data put by factory */</span></span><br><span class="line">    <span class="keyword">void</span>    *factory_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Current capacity allocated by the pool. */</span></span><br><span class="line">    <span class="keyword">pj_size_t</span>    capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Size of memory block to be allocated when the pool runs out of memory */</span></span><br><span class="line">    <span class="keyword">pj_size_t</span>    increment_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of memory blocks allcoated by the pool. */</span></span><br><span class="line">    pj_pool_block   block_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The callback to be called when the pool is unable to allocate memory. */</span></span><br><span class="line">    pj_pool_callback *callback;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>PJ_MAX_OBJ_NAME = 32，就是说内存池的名称大小要在32个字符以内</p><p>increment_size 是当空间不足时，扩容每个block的大小，比如increment=4,申请9时会，给出4*3个block并将这3个block合并</p></blockquote><p>上面有个链表结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PJ_DECL_LIST_MEMBER(type)                       \</span></span><br><span class="line">                                   <span class="comment">/** List @a prev. */</span> \</span><br><span class="line">                                   type *prev;          \</span><br><span class="line">                                   <span class="comment">/** List @a next. */</span> \</span><br><span class="line">                                   type *next </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pj_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PJ_DECL_LIST_MEMBER(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看传入的类型，分配对应类型的链表。</p><h4 id="struct-pj-pool-block"><a href="#struct-pj-pool-block" class="headerlink" title="struct pj_pool_block"></a>struct pj_pool_block</h4><p>内存池块block结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pj_pool_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PJ_DECL_LIST_MEMBER(struct pj_pool_block);  <span class="comment">/**&lt; List's prev and next.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    *buf;                      <span class="comment">/**&lt; Start of buffer.       */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    *cur;                      <span class="comment">/**&lt; Current alloc ptr.     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    *<span class="built_in">end</span>;                      <span class="comment">/**&lt; End of buffer.         */</span></span><br><span class="line">&#125; pj_pool_block;</span><br></pre></td></tr></table></figure><h4 id="struct-pj-caching-pool"><a href="#struct-pj-caching-pool" class="headerlink" title="struct pj_caching_pool"></a>struct pj_caching_pool</h4><p>缓存池</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Declaration for caching pool. Application doesn't normally need to</span></span><br><span class="line"><span class="comment"> * care about the contents of this struct, it is only provided here because</span></span><br><span class="line"><span class="comment"> * application need to define an instance of this struct (we can not allocate</span></span><br><span class="line"><span class="comment"> * the struct from a pool since there is no pool factory yet!).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pj_caching_pool</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/** Pool factory interface, must be declared first. */</span></span><br><span class="line">    pj_pool_factory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Current factory's capacity, i.e. number of bytes that are allocated</span></span><br><span class="line"><span class="comment">     *  and available for application in this factory. The factory's</span></span><br><span class="line"><span class="comment">     *  capacity represents the size of all pools kept by this factory</span></span><br><span class="line"><span class="comment">     *  in it's free list, which will be returned to application when it</span></span><br><span class="line"><span class="comment">     *  requests to create a new pool.</span></span><br><span class="line"><span class="comment">     *  当前工厂的容量大小，工厂容量代表该工厂在空闲列表中持有的所有池的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pj_size_t</span>    capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Maximum size that can be held by this factory. Once the capacity</span></span><br><span class="line"><span class="comment">     *  has exceeded @a max_capacity, further #pj_pool_release() will</span></span><br><span class="line"><span class="comment">     *  flush the pool. If the capacity is still below the @a max_capacity,</span></span><br><span class="line"><span class="comment">     *  #pj_pool_release() will save the pool to the factory's free list.</span></span><br><span class="line"><span class="comment">     *  该工厂空闲容量的最大大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pj_size_t</span>       max_capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of pools currently held by applications. This number gets</span></span><br><span class="line"><span class="comment">     * incremented everytime #pj_pool_create() is called, and gets</span></span><br><span class="line"><span class="comment">     * decremented when #pj_pool_release() is called.</span></span><br><span class="line"><span class="comment">     * 应用持有池数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pj_size_t</span>       used_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Total size of memory currently used by application.</span></span><br><span class="line"><span class="comment">     * 应用使用地内存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pj_size_t</span>    used_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum size of memory used by application throughout the life</span></span><br><span class="line"><span class="comment">     * of the caching pool.</span></span><br><span class="line"><span class="comment">     * 在缓存池的整个生命周期中，应用程序使用的最大内存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pj_size_t</span>    peak_used_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lists of pools in the cache, indexed by pool size.</span></span><br><span class="line"><span class="comment">     * 缓存池中的池列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pj_list    free_list[PJ_CACHING_POOL_ARRAY_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List of pools currently allocated by applications.</span></span><br><span class="line"><span class="comment">     * 当前应用分配的池列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pj_list    used_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>    pool_buf[<span class="number">256</span> * (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) / <span class="number">4</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Mutex.</span></span><br><span class="line"><span class="comment">     * 互斥锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pj_lock_t</span>   *lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pj_list是一个双向链表结构,记录前后节点.free_list大小为16，就是说有16条链表结构。free_list是空闲池列表，表示该表中的内存池处于空闲状态，used_list应用分配的内存池列表也就是当前正在使用的内存池列表。capacity表示当前空闲池的容量大小，max_capacity表示空闲池容量的最大大小。</p><h4 id="struct-pj-pool-factory"><a href="#struct-pj-pool-factory" class="headerlink" title="struct pj_pool_factory"></a>struct pj_pool_factory</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This structure contains the declaration for pool factory interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pj_pool_factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Memory pool policy.</span></span><br><span class="line"><span class="comment">     * 内存池策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pj_pool_factory_policy policy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a new pool from the pool factory.[从工厂中创建新池]</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param factoryThe pool factory.[工厂]</span></span><br><span class="line"><span class="comment">    * @param namethe name to be assigned to the pool. The name should </span></span><br><span class="line"><span class="comment">    *not be longer than PJ_MAX_OBJ_NAME (32 chars), or </span></span><br><span class="line"><span class="comment">    *otherwise it will be truncated.[池名称]</span></span><br><span class="line"><span class="comment">    * @param initial_size the size of initial memory blocks taken by the pool.</span></span><br><span class="line"><span class="comment">    *Note that the pool will take 68+20 bytes for </span></span><br><span class="line"><span class="comment">    *administrative area from this block.[池初始化分配到的大小]</span></span><br><span class="line"><span class="comment">    * @param increment_size the size of each additional blocks to be allocated</span></span><br><span class="line"><span class="comment">    *when the pool is running out of memory. If user </span></span><br><span class="line"><span class="comment">    *requests memory which is larger than this size, then </span></span><br><span class="line"><span class="comment">    *an error occurs.</span></span><br><span class="line"><span class="comment">    *Note that each time a pool allocates additional block, </span></span><br><span class="line"><span class="comment">    *it needs 20 bytes (equal to sizeof(pj_pool_block)) to </span></span><br><span class="line"><span class="comment">    *store some administrative info.</span></span><br><span class="line"><span class="comment">    * [池内存不足时要分配的每个其他块的大小。 而且需要20个字节存储一些管理信息]</span></span><br><span class="line"><span class="comment">    * @param callbackCllback to be called when error occurs in the pool.</span></span><br><span class="line"><span class="comment">    *Note that when an error occurs during pool creation, </span></span><br><span class="line"><span class="comment">    *the callback itself is not called. Instead, NULL </span></span><br><span class="line"><span class="comment">    *will be returned.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @return the memory pool, or NULL.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">pj_pool_t</span>*(*create_pool)( pj_pool_factory *factory,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line"><span class="keyword">pj_size_t</span> initial_size, </span><br><span class="line"><span class="keyword">pj_size_t</span> increment_size,</span><br><span class="line">pj_pool_callback *callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release the pool to the pool factory.</span></span><br><span class="line"><span class="comment">     * [释放池到工厂]</span></span><br><span class="line"><span class="comment">     * @param factoryThe pool factory.</span></span><br><span class="line"><span class="comment">     * @param poolThe pool to be released.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> (*release_pool)( pj_pool_factory *factory, <span class="keyword">pj_pool_t</span> *pool );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dump pool status to log.</span></span><br><span class="line"><span class="comment">     * [转储池状态记录]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param factoryThe pool factory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*dump_status)( pj_pool_factory *factory, <span class="keyword">pj_bool_t</span> detail );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is optional callback to be called by allocation policy when</span></span><br><span class="line"><span class="comment">     * it allocates a new memory block. The factory may use this callback</span></span><br><span class="line"><span class="comment">     * for example to keep track of the total number of memory blocks</span></span><br><span class="line"><span class="comment">     * currently allocated by applications.</span></span><br><span class="line"><span class="comment">     * [分配策略在分配新内存时的回调]</span></span><br><span class="line"><span class="comment">     * @param factory    The pool factory.</span></span><br><span class="line"><span class="comment">     * @param size    Size requested by application.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return    MUST return PJ_TRUE, otherwise the block</span></span><br><span class="line"><span class="comment">     *                      allocation is cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pj_bool_t</span> (*on_block_alloc)(pj_pool_factory *factory, <span class="keyword">pj_size_t</span> <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is optional callback to be called by allocation policy when</span></span><br><span class="line"><span class="comment">     * it frees memory block. The factory may use this callback</span></span><br><span class="line"><span class="comment">     * for example to keep track of the total number of memory blocks</span></span><br><span class="line"><span class="comment">     * currently allocated by applications.</span></span><br><span class="line"><span class="comment">     * [分配策略在释放内存时的回调]</span></span><br><span class="line"><span class="comment">     * @param factory    The pool factory.</span></span><br><span class="line"><span class="comment">     * @param size    Size freed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*on_block_free)(pj_pool_factory *factory, <span class="keyword">pj_size_t</span> <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="struct-pj-pool-factory-policy"><a href="#struct-pj-pool-factory-policy" class="headerlink" title="struct pj_pool_factory_policy"></a>struct pj_pool_factory_policy</h4><p>缓存池工厂策略</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pj_pool_factory_policy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Allocate memory block (for use by pool). This function is called</span></span><br><span class="line"><span class="comment">     * by memory pool to allocate memory block.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param factoryPool factory.</span></span><br><span class="line"><span class="comment">     * @param sizeThe size of memory block to allocate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @returnMemory block.</span></span><br><span class="line"><span class="comment">     * [分配内存]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span>* (*block_alloc)(pj_pool_factory *factory, <span class="keyword">pj_size_t</span> <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Free memory block.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param factoryPool factory.</span></span><br><span class="line"><span class="comment">     * @param memMemory block previously allocated by block_alloc().</span></span><br><span class="line"><span class="comment">     * @param sizeThe size of memory block.</span></span><br><span class="line"><span class="comment">     * [释放内存]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*block_free)(pj_pool_factory *factory, <span class="keyword">void</span> *mem, <span class="keyword">pj_size_t</span> <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default callback to be called when memory allocation fails.</span></span><br><span class="line"><span class="comment">     * [分配内存失败时的回调]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pj_pool_callback *callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Option flags.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> flags;</span><br><span class="line"></span><br><span class="line">&#125; pj_pool_factory_policy;</span><br></pre></td></tr></table></figure><h4 id="pj-caching-pool-init"><a href="#pj-caching-pool-init" class="headerlink" title="pj_caching_pool_init()"></a>pj_caching_pool_init()</h4><p>初始化缓存池</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 创建池工厂</span></span><br><span class="line"><span class="comment">* @param cp  缓存池</span></span><br><span class="line"><span class="comment">* @param policy 池工厂策略 NULL默认</span></span><br><span class="line"><span class="comment">* @param max_capacity 池容量大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">PJ_DEF(<span class="keyword">void</span>) pj_caching_pool_init( pj_caching_pool *cp, </span><br><span class="line">   <span class="keyword">const</span> pj_pool_factory_policy *policy,</span><br><span class="line">   <span class="keyword">pj_size_t</span> max_capacity)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pj_pool_t</span> *pool;</span><br><span class="line"></span><br><span class="line">    PJ_CHECK_STACK();</span><br><span class="line"></span><br><span class="line">    pj_bzero(cp, <span class="keyword">sizeof</span>(*cp));</span><br><span class="line">    <span class="comment">// 设置池容量</span></span><br><span class="line">    cp-&gt;max_capacity = max_capacity;</span><br><span class="line">    <span class="comment">// 初始化当前由应用程序分配的池列表</span></span><br><span class="line">    pj_list_init(&amp;cp-&gt;used_list);</span><br><span class="line">    <span class="comment">// 初始化缓存中的池列表</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;PJ_CACHING_POOL_ARRAY_SIZE; ++i)</span><br><span class="line">pj_list_init(&amp;cp-&gt;free_list[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果策略为空，那么设置为默认策略</span></span><br><span class="line">    <span class="keyword">if</span> (policy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    policy = &amp;pj_pool_factory_default_policy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将策略分配给池工厂</span></span><br><span class="line">    pj_memcpy(&amp;cp-&gt;factory.policy, policy, <span class="keyword">sizeof</span>(pj_pool_factory_policy));</span><br><span class="line">    <span class="comment">// 创建新池的方法</span></span><br><span class="line">    cp-&gt;factory.create_pool = &amp;cpool_create_pool;</span><br><span class="line">    <span class="comment">// 释放池的方法</span></span><br><span class="line">    cp-&gt;factory.release_pool = &amp;cpool_release_pool;</span><br><span class="line">    <span class="comment">// 转储池状态log记录</span></span><br><span class="line">    cp-&gt;factory.dump_status = &amp;cpool_dump_status;</span><br><span class="line">    <span class="comment">// 分配内存的回调</span></span><br><span class="line">    cp-&gt;factory.on_block_alloc = &amp;cpool_on_block_alloc;</span><br><span class="line">    <span class="comment">// 释放内存的回调</span></span><br><span class="line">    cp-&gt;factory.on_block_free = &amp;cpool_on_block_free;</span><br><span class="line"></span><br><span class="line">    pool = pj_pool_create_on_buf(<span class="string">"cachingpool"</span>, cp-&gt;pool_buf, <span class="keyword">sizeof</span>(cp-&gt;pool_buf));</span><br><span class="line">    pj_lock_create_simple_mutex(pool, <span class="string">"cachingpool"</span>, &amp;cp-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pj_list_init</code>，对链表进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the list.</span></span><br><span class="line"><span class="comment"> * Initially, the list will have no member, and function pj_list_empty() will</span></span><br><span class="line"><span class="comment"> * always return nonzero (which indicates TRUE) for the newly initialized </span></span><br><span class="line"><span class="comment"> * list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param node The list head.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PJ_INLINE(<span class="keyword">void</span>) pj_list_init(pj_list_type * node)</span><br><span class="line">&#123;</span><br><span class="line">    ((pj_list*)node)-&gt;next = ((pj_list*)node)-&gt;prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将当前节点前后节点都指向当前节点。</p><p>policy，管理策略，工厂只是用来管理内存池对象，对于如何分配内存（有kmalloc,malloc,new），则由策略组件来实现,默认是malloc.但是C 里并没有new，默认地分配块函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">default_block_alloc</span><span class="params">(pj_pool_factory *factory, <span class="keyword">pj_size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (factory-&gt;on_block_alloc)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    rc = factory-&gt;on_block_alloc(factory, <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (!rc)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p = <span class="built_in">malloc</span>(<span class="built_in">size</span> + (SIG_SIZE &lt;&lt; <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (factory-&gt;on_block_free)</span><br><span class="line">      factory-&gt;on_block_free(factory, <span class="built_in">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Apply signature when PJ_SAFE_POOL is set. It will move</span></span><br><span class="line"><span class="comment"> * "p" pointer forward.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    APPLY_SIG(p, <span class="built_in">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pj-pool-create"><a href="#pj-pool-create" class="headerlink" title="pj_pool_create()"></a>pj_pool_create()</h4><p>创建新池的函数指向了<code>cpool_create_pool</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pj_pool_t</span> *<span class="title">cpool_create_pool</span><span class="params">(pj_pool_factory *pf,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">pj_size_t</span> initial_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">pj_size_t</span> increment_sz,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    pj_pool_callback *callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pj_caching_pool *cp = (pj_caching_pool *)pf;</span><br><span class="line">  <span class="keyword">pj_pool_t</span> *pool;</span><br><span class="line">  <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line">  <span class="comment">// 请求锁</span></span><br><span class="line">  pj_lock_acquire(cp-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Use pool factory's policy when callback is NULL */</span></span><br><span class="line">  <span class="keyword">if</span> (callback == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    callback = pf-&gt;policy.callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 为内存池的寻找合适大小，已经为你推荐了16个池的大小</span></span><br><span class="line"><span class="comment">  * 从找到大于等于initial_size并且最接近inintial_size大小</span></span><br><span class="line"><span class="comment">  * 如果大于这16个大小，那么就直接使用initial_size.</span></span><br><span class="line"><span class="comment">  * START_SIZE = 5</span></span><br><span class="line"><span class="comment">  * pool_sizes = &#123;</span></span><br><span class="line"><span class="comment">        256, 512, 1024, 2048, 4096, 8192, 12288, 16384,</span></span><br><span class="line"><span class="comment">        20480, 24576, 28672, 32768, 40960, 49152, 57344, 65536&#125;;</span></span><br><span class="line"><span class="comment">    从12288为分界线，二分查找</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (initial_size &lt;= pool_sizes[START_SIZE])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (idx = START_SIZE - <span class="number">1</span>;</span><br><span class="line">         idx &gt;= <span class="number">0</span> &amp;&amp; pool_sizes[idx] &gt;= initial_size;</span><br><span class="line">         --idx)</span><br><span class="line">      ;</span><br><span class="line">    ++idx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (idx = START_SIZE + <span class="number">1</span>;</span><br><span class="line">         idx &lt; PJ_CACHING_POOL_ARRAY_SIZE &amp;&amp;</span><br><span class="line">         pool_sizes[idx] &lt; initial_size;</span><br><span class="line">         ++idx)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check whether there's a pool in the list. */</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 如果initial_size&gt;65536即idx==16,或者idx&lt;16并且free_list[idx]为空时进入</span></span><br><span class="line"><span class="comment">  * 就是此时空闲池list中没有空闲的内存，所以要创建一个</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (idx == PJ_CACHING_POOL_ARRAY_SIZE || pj_list_empty(&amp;cp-&gt;free_list[idx]))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* No pool is available. */</span></span><br><span class="line">    <span class="comment">/* Set minimum size. */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果idx&lt;16,将initial_size设置为推荐大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (idx &lt; PJ_CACHING_POOL_ARRAY_SIZE)</span><br><span class="line">      initial_size = pool_sizes[idx];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create new pool */</span></span><br><span class="line">    pool = pj_pool_create_int(&amp;cp-&gt;factory, name, initial_size,</span><br><span class="line">                              increment_sz, callback);</span><br><span class="line">    <span class="keyword">if</span> (!pool)</span><br><span class="line">    &#123;</span><br><span class="line">      pj_lock_release(cp-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 此时idx&lt;16,并且free_list[idx]不为空时</span></span><br><span class="line"><span class="comment">    * 此时空闲池中存在空闲的内存</span></span><br><span class="line"><span class="comment">    * 直接将对应头节点的next节点给pool.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* Get one pool from the list. */</span></span><br><span class="line">    pool = (<span class="keyword">pj_pool_t</span> *)cp-&gt;free_list[idx].next;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将pool从free_list中移除</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pj_list_erase(pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the pool. */</span></span><br><span class="line">    pj_pool_init_int(pool, name, increment_sz, callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update pool manager's free capacity. */</span></span><br><span class="line">    <span class="comment">// 因为空闲池被分配了，所以空闲池容量要减去被分配的容量</span></span><br><span class="line">    cp-&gt;capacity -= pj_pool_get_capacity(pool);</span><br><span class="line"></span><br><span class="line">    PJ_LOG(<span class="number">6</span>, (pool-&gt;obj_name, <span class="string">"pool reused, size=%u"</span>, pool-&gt;capacity));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Put in used list. */</span></span><br><span class="line">  <span class="comment">// 将新分配的空闲池插入到used_list的最后</span></span><br><span class="line">  pj_list_insert_before(&amp;cp-&gt;used_list, pool);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark factory data */</span></span><br><span class="line">  pool-&gt;factory_data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)idx;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Increment used count. */</span></span><br><span class="line">  ++cp-&gt;used_count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放锁</span></span><br><span class="line">  pj_lock_release(cp-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pj_list_empty判断该节点是否为空：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check that the list is empty.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param nodeThe list head.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Non-zero if the list is not-empty, or zero if it is empty.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PJ_INLINE(<span class="keyword">int</span>) pj_list_empty(<span class="keyword">const</span> pj_list_type * node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((pj_list*)node)-&gt;next == node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里判断node的下个节点是否指向自己，所以为空时应该返回true，但是这里注释说为空时返回0，应该是有问题的</p></blockquote><p>上面的初始化池大小策略是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">PJ_DEF(<span class="keyword">pj_pool_t</span> *) pj_pool_create_int(pj_pool_factory *f, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                   <span class="keyword">pj_size_t</span> initial_size,</span><br><span class="line">                   <span class="keyword">pj_size_t</span> increment_size,</span><br><span class="line">                   pj_pool_callback *callback)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pj_pool_t</span> *pool;</span><br><span class="line">  pj_pool_block *block;</span><br><span class="line">  <span class="keyword">pj_uint8_t</span> *<span class="built_in">buffer</span>;</span><br><span class="line"></span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Size must be at least sizeof(pj_pool)+sizeof(pj_pool_block) */</span></span><br><span class="line">  PJ_ASSERT_RETURN(initial_size &gt;= <span class="keyword">sizeof</span>(<span class="keyword">pj_pool_t</span>) + <span class="keyword">sizeof</span>(pj_pool_block),</span><br><span class="line">                   <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If callback is NULL, set calback from the policy */</span></span><br><span class="line">  <span class="keyword">if</span> (callback == <span class="literal">NULL</span>)</span><br><span class="line">    callback = f-&gt;policy.callback;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate initial block */</span></span><br><span class="line">  <span class="built_in">buffer</span> = (<span class="keyword">pj_uint8_t</span> *)(*f-&gt;policy.block_alloc)(f, initial_size);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">buffer</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set pool administrative data. */</span></span><br><span class="line">  pool = (<span class="keyword">pj_pool_t</span> *)<span class="built_in">buffer</span>;</span><br><span class="line">  pj_bzero(pool, <span class="keyword">sizeof</span>(*pool));</span><br><span class="line"></span><br><span class="line">  pj_list_init(&amp;pool-&gt;block_list);</span><br><span class="line">  pool-&gt;factory = f;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Create the first block from the memory. */</span></span><br><span class="line">  block = (pj_pool_block *)(<span class="built_in">buffer</span> + <span class="keyword">sizeof</span>(*pool));</span><br><span class="line">  block-&gt;cur = block-&gt;buf = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)block) + <span class="keyword">sizeof</span>(pj_pool_block);</span><br><span class="line">  block-&gt;<span class="built_in">end</span> = <span class="built_in">buffer</span> + initial_size;</span><br><span class="line">  <span class="comment">// 将block插到block_list的后面</span></span><br><span class="line">  pj_list_insert_after(&amp;pool-&gt;block_list, block);</span><br><span class="line"></span><br><span class="line">  pj_pool_init_int(pool, name, increment_size, callback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pool initial capacity and used size */</span></span><br><span class="line">  pool-&gt;capacity = initial_size;</span><br><span class="line"></span><br><span class="line">  LOG((pool-&gt;obj_name, <span class="string">"pool created, size=%u"</span>, pool-&gt;capacity));</span><br><span class="line">  <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里插入节点的函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PJ_IDEF(<span class="keyword">void</span>) pj_list_insert_after(pj_list_type *pos, pj_list_type *node)</span><br><span class="line">&#123;</span><br><span class="line">    ((pj_list*)node)-&gt;prev = pos;</span><br><span class="line">    ((pj_list*)node)-&gt;next = ((pj_list*)pos)-&gt;next;</span><br><span class="line">    ((pj_list*) ((pj_list*)pos)-&gt;next) -&gt;prev = node;</span><br><span class="line">    ((pj_list*)pos)-&gt;next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析其形成了循环链表，头指向尾指向头。</p><p>将分配的空间节点从空闲池中移除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Internal */</span></span><br><span class="line">PJ_INLINE(<span class="keyword">void</span>) pj_link_node(pj_list_type *prev, pj_list_type *next)</span><br><span class="line">&#123;</span><br><span class="line">    ((pj_list*)prev)-&gt;next = next;</span><br><span class="line">    ((pj_list*)next)-&gt;prev = prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PJ_IDEF(<span class="keyword">void</span>) pj_list_erase(pj_list_type *node)</span><br><span class="line">&#123;</span><br><span class="line">    pj_link_node( ((pj_list*)node)-&gt;prev, ((pj_list*)node)-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* It'll be safer to init the next/prev fields to itself, to</span></span><br><span class="line"><span class="comment">     * prevent multiple erase() from corrupting the list. See</span></span><br><span class="line"><span class="comment">     * ticket #520 for one sample bug.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pj_list_init(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是将头节点的next指向头节点的next的next，将头节点的next的next的pre指向头节点，然后让头节点的next的pre和next都指向自己，简而言之就是将头节点的next移出来，将其该节点孤立。</p><p><code>pj_list_insert_before(&amp;cp-&gt;used_list, pool);</code></p><p>将分配的内存插入到<code>used_list</code>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PJ_IDEF(<span class="keyword">void</span>) pj_list_insert_before(pj_list_type *pos, pj_list_type *node)</span><br><span class="line">&#123;</span><br><span class="line">    pj_list_insert_after(((pj_list*)pos)-&gt;prev, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>pj_list_insert_after</code>代码之前已经提及到，这里就是说将当前节点插入到used_list的最后末尾，也是一个循环双向链表。</p><h4 id="pool-release-pool"><a href="#pool-release-pool" class="headerlink" title="pool_release_pool()"></a>pool_release_pool()</h4><p>释放池pool_release_pool指向了cpool_release_pool.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpool_release_pool</span><span class="params">(pj_pool_factory *pf, <span class="keyword">pj_pool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pj_caching_pool *cp = (pj_caching_pool *)pf;</span><br><span class="line">  <span class="keyword">unsigned</span> pool_capacity;</span><br><span class="line">  <span class="keyword">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line"></span><br><span class="line">  PJ_ASSERT_ON_FAIL(pf &amp;&amp; pool, <span class="keyword">return</span> );</span><br><span class="line"></span><br><span class="line">  pj_lock_acquire(cp-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PJ_SAFE_POOL</span></span><br><span class="line">  <span class="comment">/* Make sure pool is still in our used list */</span></span><br><span class="line">  <span class="keyword">if</span> (pj_list_find_node(&amp;cp-&gt;used_list, pool) != pool)</span><br><span class="line">  &#123;</span><br><span class="line">    pj_assert(!<span class="string">"Attempt to destroy pool that has been destroyed before"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Erase from the used list. */</span></span><br><span class="line">  pj_list_erase(pool);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Decrement used count. */</span></span><br><span class="line">  --cp-&gt;used_count;</span><br><span class="line"></span><br><span class="line">  pool_capacity = pj_pool_get_capacity(pool);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Destroy the pool if the size is greater than our size or if the total</span></span><br><span class="line"><span class="comment">     * capacity in our recycle list (plus the size of the pool) exceeds </span></span><br><span class="line"><span class="comment">     * maximum capacity.</span></span><br><span class="line"><span class="comment">     * 当分配的这块内存大于之前预设内存大小最大值也就是大于pool_sizes[15] = 65536，</span></span><br><span class="line"><span class="comment">     * 或者空闲容量+当前释放的容量之和大于max空闲容量最大值时，直接销毁该内存池，</span></span><br><span class="line"><span class="comment">   . */</span></span><br><span class="line">  <span class="keyword">if</span> (pool_capacity &gt; pool_sizes[PJ_CACHING_POOL_ARRAY_SIZE - <span class="number">1</span>] ||</span><br><span class="line">      cp-&gt;capacity + pool_capacity &gt; cp-&gt;max_capacity)</span><br><span class="line">  &#123;</span><br><span class="line">    pj_pool_destroy_int(pool);</span><br><span class="line">    pj_lock_release(cp-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset pool. */</span></span><br><span class="line">  PJ_LOG(<span class="number">6</span>, (pool-&gt;obj_name, <span class="string">"recycle(): cap=%d, used=%d(%d%%)"</span>,</span><br><span class="line">             pool_capacity, pj_pool_get_used_size(pool),</span><br><span class="line">             pj_pool_get_used_size(pool) * <span class="number">100</span> / pool_capacity));</span><br><span class="line">  pj_pool_reset(pool);</span><br><span class="line"></span><br><span class="line">  pool_capacity = pj_pool_get_capacity(pool);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Otherwise put the pool in our recycle list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  i = (<span class="keyword">unsigned</span>)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)pool-&gt;factory_data;</span><br><span class="line"></span><br><span class="line">  pj_assert(i &lt; PJ_CACHING_POOL_ARRAY_SIZE);</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= PJ_CACHING_POOL_ARRAY_SIZE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Something has gone wrong with the pool. */</span></span><br><span class="line">    pj_pool_destroy_int(pool);</span><br><span class="line">    pj_lock_release(cp-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将释放的放的内存是放到对应free_list对应大小的链表上</span></span><br><span class="line">  pj_list_insert_after(&amp;cp-&gt;free_list[i], pool);</span><br><span class="line">  cp-&gt;capacity += pool_capacity;</span><br><span class="line"></span><br><span class="line">  pj_lock_release(cp-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找该池是否在used_list里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PJ_IDEF(pj_list_type*) pj_list_find_node(pj_list_type *<span class="built_in">list</span>, pj_list_type *node)</span><br><span class="line">&#123;</span><br><span class="line">    pj_list *p = (pj_list *) ((pj_list*)<span class="built_in">list</span>)-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="built_in">list</span> &amp;&amp; p != node)</span><br><span class="line">p = (pj_list *) p-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p==node ? p : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是个双向循环链表，所以当p不等于头节点并且p不等于目标节点才进入循环，当循环退出，判断p是否等于目标节点即可。</p><p>销毁内存池<code>pj_pool_destroy_int(pool)</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PJ_DEF(<span class="keyword">void</span>)</span><br><span class="line">pj_pool_destroy_int(<span class="keyword">pj_pool_t</span> *pool)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pj_size_t</span> initial_size;</span><br><span class="line"></span><br><span class="line">  LOG((pool-&gt;obj_name, <span class="string">"destroy(): cap=%d, used=%d(%d%%), block0=%p-%p"</span>,</span><br><span class="line">       pool-&gt;capacity, pj_pool_get_used_size(pool),</span><br><span class="line">       pj_pool_get_used_size(pool) * <span class="number">100</span> / pool-&gt;capacity,</span><br><span class="line">       ((pj_pool_block *)pool-&gt;block_list.next)-&gt;buf,</span><br><span class="line">       ((pj_pool_block *)pool-&gt;block_list.next)-&gt;<span class="built_in">end</span>));</span><br><span class="line">  <span class="comment">// 将内存池重置会初始化的状态</span></span><br><span class="line">  reset_pool(pool);</span><br><span class="line">  initial_size = ((pj_pool_block *)pool-&gt;block_list.next)-&gt;<span class="built_in">end</span> -</span><br><span class="line">                 (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)pool;</span><br><span class="line">  <span class="comment">// 将初始的内存释放</span></span><br><span class="line">  <span class="keyword">if</span> (pool-&gt;factory-&gt;policy.block_free)</span><br><span class="line">    (*pool-&gt;factory-&gt;policy.block_free)(pool-&gt;factory, pool, initial_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重置内存池的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reset the pool to the state when it was created.</span></span><br><span class="line"><span class="comment"> * All blocks will be deallocated except the first block. All memory areas</span></span><br><span class="line"><span class="comment"> * are marked as free.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset_pool</span><span class="params">(<span class="keyword">pj_pool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pj_pool_block *block;</span><br><span class="line"></span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line">  <span class="comment">// 回到block_list的尾巴</span></span><br><span class="line">  block = pool-&gt;block_list.prev;</span><br><span class="line">  <span class="comment">// 如果尾巴跟头是同一个就直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (block == &amp;pool-&gt;block_list)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Skip the first block because it is occupying the same memory</span></span><br><span class="line"><span class="comment">       as the pool itself.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="comment">// 回到倒数第二个节点</span></span><br><span class="line">  block = block-&gt;prev;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (block != &amp;pool-&gt;block_list)</span><br><span class="line">  &#123;</span><br><span class="line">    pj_pool_block *prev = block-&gt;prev;</span><br><span class="line">    pj_list_erase(block);</span><br><span class="line">    (*pool-&gt;factory-&gt;policy.block_free)(pool-&gt;factory, block,</span><br><span class="line">                                        block-&gt;<span class="built_in">end</span> - (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)block);</span><br><span class="line">    block = prev;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  block = pool-&gt;block_list.next;</span><br><span class="line">  block-&gt;cur = block-&gt;buf;</span><br><span class="line">  pool-&gt;capacity = block-&gt;<span class="built_in">end</span> - (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出重置的时候是将最后一个节点保留了下来，把之前的节点全部释放。</p><h4 id="pj-pool-alloc"><a href="#pj-pool-alloc" class="headerlink" title="pj_pool_alloc()"></a>pj_pool_alloc()</h4><p>分配内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PJ_IDEF(<span class="keyword">void</span> *)</span><br><span class="line">pj_pool_alloc(<span class="keyword">pj_pool_t</span> *pool, <span class="keyword">pj_size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> *ptr = pj_pool_alloc_from_block(pool-&gt;block_list.next, <span class="built_in">size</span>);</span><br><span class="line">  <span class="keyword">if</span> (!ptr)</span><br><span class="line">    ptr = pj_pool_allocate_find(pool, <span class="built_in">size</span>);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会在该内存池中block_list后的第一块block中找是否有size的空间。如果有那么直接返回ptr，否则在后面的block寻找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PJ_IDEF(<span class="keyword">void</span> *)</span><br><span class="line">pj_pool_alloc_from_block(pj_pool_block *block, <span class="keyword">pj_size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The operation below is valid for size==0. </span></span><br><span class="line"><span class="comment">     * When size==0, the function will return the pointer to the pool</span></span><br><span class="line"><span class="comment">     * memory address, but no memory will be allocated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size</span> &amp; (PJ_POOL_ALIGNMENT - <span class="number">1</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">size</span> = (<span class="built_in">size</span> + PJ_POOL_ALIGNMENT) &amp; ~(PJ_POOL_ALIGNMENT - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span>)(block-&gt;<span class="built_in">end</span> - block-&gt;cur) &gt;= <span class="built_in">size</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = block-&gt;cur;</span><br><span class="line">    block-&gt;cur += <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对size进行了变换，编程以4个字节的倍数大小size，因为整数类型会占到4个字节. 如果没有足够的空间则返回NULL，如果是0则不分配内存。</p><p>这里是对第一块没有足够空间的情况下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allocate memory chunk for user from available blocks.</span></span><br><span class="line"><span class="comment"> * This will iterate through block list to find space to allocate the chunk.</span></span><br><span class="line"><span class="comment"> * If no space is available in all the blocks, a new block might be created</span></span><br><span class="line"><span class="comment"> * (depending on whether the pool is allowed to resize).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PJ_DEF(<span class="keyword">void</span> *)</span><br><span class="line">pj_pool_allocate_find(<span class="keyword">pj_pool_t</span> *pool, <span class="keyword">unsigned</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">  pj_pool_block *block = pool-&gt;block_list.next;</span><br><span class="line">  <span class="keyword">void</span> *p;</span><br><span class="line">  <span class="keyword">unsigned</span> block_size;</span><br><span class="line"></span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line">  <span class="comment">// 从第一块block遍历block_list寻找有足够大小的空间</span></span><br><span class="line">  <span class="keyword">while</span> (block != &amp;pool-&gt;block_list)</span><br><span class="line">  &#123;</span><br><span class="line">    p = pj_pool_alloc_from_block(block, <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    block = block-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* No available space in all blocks. */</span></span><br><span class="line">   <span class="comment">// 如果所有的block都没有足够的空间</span></span><br><span class="line">  <span class="comment">/* If pool is configured NOT to expand, return error. */</span></span><br><span class="line">  <span class="comment">// 那么判断increment_size是否为0</span></span><br><span class="line">  <span class="keyword">if</span> (pool-&gt;increment_size == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG((pool-&gt;obj_name, <span class="string">"Can't expand pool to allocate %u bytes "</span></span><br><span class="line">                         <span class="string">"(used=%u, cap=%u)"</span>,</span><br><span class="line">         <span class="built_in">size</span>, pj_pool_get_used_size(pool), pool-&gt;capacity));</span><br><span class="line">    (*pool-&gt;callback)(pool, <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If pool is configured to expand, but the increment size</span></span><br><span class="line"><span class="comment">     * is less than the required size, expand the pool by multiple</span></span><br><span class="line"><span class="comment">     * increment size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 如果increment_size大于0，那么其是可支持扩展的</span></span><br><span class="line">  <span class="comment">// 这里是如果increment_size太小的情况，进行分块处理</span></span><br><span class="line">  <span class="keyword">if</span> (pool-&gt;increment_size &lt; <span class="built_in">size</span> + <span class="keyword">sizeof</span>(pj_pool_block))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> count;</span><br><span class="line">    count = (<span class="built_in">size</span> + pool-&gt;increment_size + <span class="keyword">sizeof</span>(pj_pool_block)) /</span><br><span class="line">            pool-&gt;increment_size;</span><br><span class="line">    block_size = count * pool-&gt;increment_size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    block_size = pool-&gt;increment_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG((pool-&gt;obj_name,</span><br><span class="line">       <span class="string">"%u bytes requested, resizing pool by %u bytes (used=%u, cap=%u)"</span>,</span><br><span class="line">       <span class="built_in">size</span>, block_size, pj_pool_get_used_size(pool), pool-&gt;capacity));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  block = pj_pool_create_block(pool, block_size);</span><br><span class="line">  <span class="keyword">if</span> (!block)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  p = pj_pool_alloc_from_block(block, <span class="built_in">size</span>);</span><br><span class="line">  pj_assert(p != <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PJ_DEBUG</span></span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    p = p;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上先遍历block_list的看是否有足够的空间，如果空间不足，则看是否可以扩展，如果可以扩展，那么看扩展block大小是否过小，如果过小要考虑分块存储，将分的块合并成一块，然后开始创建block.在从创建好的block寻找空间</p><blockquote><p>这里又对第一块block也就是block_list.next 找了一遍实际上没有必要，因为之前已经找过一次了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create new block.</span></span><br><span class="line"><span class="comment"> * Create a new big chunk of memory block, from which user allocation will be</span></span><br><span class="line"><span class="comment"> * taken from.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> pj_pool_block *<span class="title">pj_pool_create_block</span><span class="params">(<span class="keyword">pj_pool_t</span> *pool, <span class="keyword">pj_size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pj_pool_block *block;</span><br><span class="line"></span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line">  pj_assert(<span class="built_in">size</span> &gt;= <span class="keyword">sizeof</span>(pj_pool_block));</span><br><span class="line"></span><br><span class="line">  LOG((pool-&gt;obj_name, <span class="string">"create_block(sz=%u), cur.cap=%u, cur.used=%u"</span>,</span><br><span class="line">       <span class="built_in">size</span>, pool-&gt;capacity, pj_pool_get_used_size(pool)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Request memory from allocator. */</span></span><br><span class="line">  <span class="comment">// 分配block</span></span><br><span class="line">  block = (pj_pool_block *)(*pool-&gt;factory-&gt;policy.block_alloc)(pool-&gt;factory, <span class="built_in">size</span>);</span><br><span class="line">  <span class="keyword">if</span> (block == <span class="literal">NULL</span>)<span class="comment">// 异常处理回调</span></span><br><span class="line">  &#123;</span><br><span class="line">    (*pool-&gt;callback)(pool, <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add capacity. */</span></span><br><span class="line">  pool-&gt;capacity += <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set block attribytes. */</span></span><br><span class="line">  block-&gt;cur = block-&gt;buf = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)block) + <span class="keyword">sizeof</span>(pj_pool_block);</span><br><span class="line">  block-&gt;<span class="built_in">end</span> = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)block) + <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Insert in the front of the list. */</span></span><br><span class="line">  pj_list_insert_after(&amp;pool-&gt;block_list, block);</span><br><span class="line"></span><br><span class="line">  LOG((pool-&gt;obj_name, <span class="string">" block created, buffer=%p-%p"</span>, block-&gt;buf, block-&gt;<span class="built_in">end</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将创建好的block接在block_list的后面，然后返回该block指针。</p><h4 id="pj-caching-pool-destroy"><a href="#pj-caching-pool-destroy" class="headerlink" title="pj_caching_pool_destroy()"></a>pj_caching_pool_destroy()</h4><p>销毁缓存池</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">PJ_DEF(<span class="keyword">void</span>)</span><br><span class="line">pj_caching_pool_destroy(pj_caching_pool *cp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">pj_pool_t</span> *pool;</span><br><span class="line"></span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Delete all pool in free list */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PJ_CACHING_POOL_ARRAY_SIZE; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">pj_pool_t</span> *pool = (<span class="keyword">pj_pool_t</span> *)cp-&gt;free_list[i].next;</span><br><span class="line">    <span class="keyword">pj_pool_t</span> *next;</span><br><span class="line">    <span class="keyword">for</span> (; pool != (<span class="keyword">void</span> *)&amp;cp-&gt;free_list[i]; pool = next)</span><br><span class="line">    &#123;</span><br><span class="line">      next = pool-&gt;next;</span><br><span class="line">      pj_list_erase(pool);</span><br><span class="line">      pj_pool_destroy_int(pool);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Delete all pools in used list */</span></span><br><span class="line">  pool = (<span class="keyword">pj_pool_t</span> *)cp-&gt;used_list.next;</span><br><span class="line">  <span class="keyword">while</span> (pool != (<span class="keyword">pj_pool_t</span> *)&amp;cp-&gt;used_list)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">pj_pool_t</span> *next = pool-&gt;next;</span><br><span class="line">    pj_list_erase(pool);</span><br><span class="line">    PJ_LOG(<span class="number">4</span>, (pool-&gt;obj_name,</span><br><span class="line">               <span class="string">"Pool is not released by application, releasing now"</span>));</span><br><span class="line">    pj_pool_destroy_int(pool);</span><br><span class="line">    pool = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cp-&gt;lock)</span><br><span class="line">  &#123;</span><br><span class="line">    pj_lock_destroy(cp-&gt;lock);</span><br><span class="line">    pj_lock_create_null_mutex(<span class="literal">NULL</span>, <span class="string">"cachingpool"</span>, &amp;cp-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会先遍历free_list销毁空闲内存池，然后遍历used_list销毁应用分配得内存池，然后将锁销毁。</p><h4 id="dump-status"><a href="#dump-status" class="headerlink" title="dump_status()"></a>dump_status()</h4><p>在初始化时dump_status指向了cpool_dump_status</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpool_dump_status</span><span class="params">(pj_pool_factory *factory, <span class="keyword">pj_bool_t</span> detail)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PJ_LOG_MAX_LEVEL &gt;= 3</span></span><br><span class="line">  pj_caching_pool *cp = (pj_caching_pool *)factory;</span><br><span class="line"></span><br><span class="line">  pj_lock_acquire(cp-&gt;lock);</span><br><span class="line"></span><br><span class="line">  PJ_LOG(<span class="number">3</span>, (<span class="string">"cachpool"</span>, <span class="string">" Dumping caching pool:"</span>));</span><br><span class="line">  PJ_LOG(<span class="number">3</span>, (<span class="string">"cachpool"</span>, <span class="string">"   Capacity=%u, max_capacity=%u, used_cnt=%u"</span>,</span><br><span class="line">             cp-&gt;capacity, cp-&gt;max_capacity, cp-&gt;used_count));</span><br><span class="line">  <span class="keyword">if</span> (detail)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">pj_pool_t</span> *pool = (<span class="keyword">pj_pool_t</span> *)cp-&gt;used_list.next;</span><br><span class="line">    <span class="keyword">pj_uint32_t</span> total_used = <span class="number">0</span>, total_capacity = <span class="number">0</span>;</span><br><span class="line">    PJ_LOG(<span class="number">3</span>, (<span class="string">"cachpool"</span>, <span class="string">"  Dumping all active pools:"</span>));</span><br><span class="line">    <span class="keyword">while</span> (pool != (<span class="keyword">void</span> *)&amp;cp-&gt;used_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">unsigned</span> pool_capacity = pj_pool_get_capacity(pool);</span><br><span class="line">      PJ_LOG(<span class="number">3</span>, (<span class="string">"cachpool"</span>, <span class="string">"   %12s: %8d of %8d (%d%%) used"</span>,</span><br><span class="line">                 pj_pool_getobjname(pool),</span><br><span class="line">                 pj_pool_get_used_size(pool),</span><br><span class="line">                 pool_capacity,</span><br><span class="line">                 pj_pool_get_used_size(pool) * <span class="number">100</span> / pool_capacity));</span><br><span class="line">      total_used += pj_pool_get_used_size(pool);</span><br><span class="line">      total_capacity += pool_capacity;</span><br><span class="line">      pool = pool-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (total_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">      PJ_LOG(<span class="number">3</span>, (<span class="string">"cachpool"</span>, <span class="string">"  Total %9d of %9d (%d %%) used!"</span>,</span><br><span class="line">                 total_used, total_capacity,</span><br><span class="line">                 total_used * <span class="number">100</span> / total_capacity));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pj_lock_release(cp-&gt;lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  PJ_UNUSED_ARG(factory);</span><br><span class="line">  PJ_UNUSED_ARG(detail);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果detail为false，就只会打印简要信息，会打印空闲容量的大小，和空闲容量的最大大小，以及应用持有的内存池数量。如果detail为true，那么还会打印应用持有的每个内存池的名称，已经内存池使用的大小，以及内存池容量，以及占用的百分比，还有应用全部持有的内存池大小，以及全部内存池的容量，以及其占用百分比。</p><h2 id="定时器模块"><a href="#定时器模块" class="headerlink" title="定时器模块"></a>定时器模块</h2><p>pjlib定时器是从ACE网络库移植过来的。实现在timer.h和timer.c，定时器的原理是有个将来的超时时间，这个时间就是现在时间加上定时器时长。</p><h3 id="源代码解析-1"><a href="#源代码解析-1" class="headerlink" title="源代码解析"></a>源代码解析</h3><h4 id="struct-pj-timer-entry"><a href="#struct-pj-timer-entry" class="headerlink" title="struct pj_timer_entry"></a>struct pj_timer_entry</h4><p>计时器项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This structure represents an entry to the timer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pj_timer_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * User data to be associated with this entry. </span></span><br><span class="line"><span class="comment">     * Applications normally will put the instance of object that</span></span><br><span class="line"><span class="comment">     * owns the timer entry in this field.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> *user_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Arbitrary ID assigned by the user/owner of this entry. </span></span><br><span class="line"><span class="comment">     * Applications can use this ID to distinguish multiple</span></span><br><span class="line"><span class="comment">     * timer entries that share the same callback and user_data.</span></span><br><span class="line"><span class="comment">     * [用户分配的id]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Callback to be called when the timer expires. </span></span><br><span class="line"><span class="comment">     * [计时器到期后的回调]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pj_timer_heap_callback *cb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Internal unique timer ID, which is assigned by the timer heap. </span></span><br><span class="line"><span class="comment">     * Application should not touch this ID.</span></span><br><span class="line"><span class="comment">     * [计时器内部唯一id]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pj_timer_id_t</span> _timer_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * The future time when the timer expires, which the value is updated</span></span><br><span class="line"><span class="comment">     * by timer heap when the timer is scheduled.</span></span><br><span class="line"><span class="comment">     * [过期时间]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pj_time_val _timer_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>_timer_id就是指entry在timer_ids的下标即index。</p></blockquote><h4 id="struct-pj-timer-heap-t"><a href="#struct-pj-timer-heap-t" class="headerlink" title="struct pj_timer_heap_t"></a>struct pj_timer_heap_t</h4><p>计时器堆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">struct pj_timer_heap_t</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;** Pool from which the timer heap resize will get the storage from *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; [计时器从该内存池中获取内存]</span><br><span class="line">    pj_pool_t *pool;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Maximum size of the heap. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; [堆的最大大小]</span><br><span class="line">    pj_size_t max_size;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Current size of the heap. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; [堆当前的大小]</span><br><span class="line">    pj_size_t cur_size;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Max timed out entries to process per poll. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; [每个轮询最多可处理的超时项]</span><br><span class="line">    unsigned max_entries_per_poll;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Lock object. *&#x2F;</span><br><span class="line">    pj_lock_t *lock;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Autodelete lock. *&#x2F;</span><br><span class="line">    pj_bool_t auto_delete_lock;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Current contents of the Heap, which is organized as a &quot;heap&quot; of</span><br><span class="line">     * pj_timer_entry *&#39;s.  In this context, a heap is a &quot;partially</span><br><span class="line">     * ordered, almost complete&quot; binary tree, which is stored in an</span><br><span class="line">     * array.</span><br><span class="line">     * [堆 近乎二叉树]</span><br><span class="line">     *&#x2F;</span><br><span class="line">    pj_timer_entry **heap;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * An array of &quot;pointers&quot; that allows each pj_timer_entry in the</span><br><span class="line">     * &lt;heap_&gt; to be located in O(1) time.  Basically, &lt;timer_id_[i]&gt;</span><br><span class="line">     * contains the slot in the &lt;heap_&gt; array where an pj_timer_entry</span><br><span class="line">     * with timer id &lt;i&gt; resides.  Thus, the timer id passed back from</span><br><span class="line">     * &lt;schedule_entry&gt; is really an slot into the &lt;timer_ids&gt; array.  The</span><br><span class="line">     * &lt;timer_ids_&gt; array serves two purposes: negative values are</span><br><span class="line">     * treated as &quot;pointers&quot; for the &lt;freelist_&gt;, whereas positive</span><br><span class="line">     * values are treated as &quot;pointers&quot; into the &lt;heap_&gt; array.</span><br><span class="line">     * [计时项的指针数组 复杂度O(1)]</span><br><span class="line">     *&#x2F;</span><br><span class="line">    pj_timer_id_t *timer_ids;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &quot;Pointer&quot; to the first element in the freelist contained within</span><br><span class="line">     * the &lt;timer_ids_&gt; array, which is organized as a stack.</span><br><span class="line">     * [是空闲表中第一个元素，timer_ids的index]</span><br><span class="line">     *&#x2F;</span><br><span class="line">    pj_timer_id_t timer_ids_freelist;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Callback to be called when a timer expires. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; [计时器过期时的回调]</span><br><span class="line">    pj_timer_heap_callback *callback;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>timer_ids 中的值表示entry在二叉树heap数组中的位置，负数是timer_ids初始状态，并且初始的状态的值是其timer_ids下标index的加一的相反数，也就是说是记录了自己下一位的index的相反数，timer_ids[0]不记录，timer_ids从1开始依次记录entry，free_list指向了还未被entry占位的timer_ids的下标index，所以每次加入entry时要将entry的_timer_id = free_list,然后让free_list向后移一位，也就是此时timer_ids的index的值的相反数。就是timer_ids跟heap相互记录了对方的位置，便于相互查询。</p></blockquote><h4 id="pj-timer-heap-create"><a href="#pj-timer-heap-create" class="headerlink" title="pj_timer_heap_create()"></a>pj_timer_heap_create()</h4><p>创建计时器堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a timer heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pool      The pool where allocations in the timer heap will be </span></span><br><span class="line"><span class="comment"> *                  allocated. The timer heap will dynamicly allocate </span></span><br><span class="line"><span class="comment"> *                  more storate from the pool if the number of timer </span></span><br><span class="line"><span class="comment"> *                  entries registered is more than the size originally </span></span><br><span class="line"><span class="comment"> *                  requested when calling this function.[内存池]</span></span><br><span class="line"><span class="comment"> * @param count     The maximum number of timer entries to be supported </span></span><br><span class="line"><span class="comment"> *                  initially. If the application registers more entries </span></span><br><span class="line"><span class="comment"> *                  during runtime, then the timer heap will resize.</span></span><br><span class="line"><span class="comment"> *     [计时器项的最大数量]</span></span><br><span class="line"><span class="comment"> * @param ht        Pointer to receive the created timer heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return          PJ_SUCCESS, or the appropriate error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PJ_DEF(<span class="keyword">pj_status_t</span>)</span><br><span class="line">pj_timer_heap_create(<span class="keyword">pj_pool_t</span> *pool,</span><br><span class="line">                     <span class="keyword">pj_size_t</span> <span class="built_in">size</span>,</span><br><span class="line">                     <span class="keyword">pj_timer_heap_t</span> **p_heap)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pj_timer_heap_t</span> *ht;</span><br><span class="line">  <span class="keyword">pj_size_t</span> i;</span><br><span class="line"></span><br><span class="line">  PJ_ASSERT_RETURN(pool &amp;&amp; p_heap, PJ_EINVAL);</span><br><span class="line"></span><br><span class="line">  *p_heap = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Magic? */</span></span><br><span class="line">  <span class="built_in">size</span> += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate timer heap data structure from the pool */</span></span><br><span class="line">  <span class="comment">// 分配heap数据结构体的内存</span></span><br><span class="line">  ht = PJ_POOL_ALLOC_T(pool, <span class="keyword">pj_timer_heap_t</span>);</span><br><span class="line">  <span class="keyword">if</span> (!ht)</span><br><span class="line">    <span class="keyword">return</span> PJ_ENOMEM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize timer heap sizes */</span></span><br><span class="line">  ht-&gt;max_size = <span class="built_in">size</span>;</span><br><span class="line">  ht-&gt;cur_size = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 每次轮询最大超时项为64</span></span><br><span class="line">  ht-&gt;max_entries_per_poll = DEFAULT_MAX_TIMED_OUT_PER_POLL;</span><br><span class="line">  ht-&gt;timer_ids_freelist = <span class="number">1</span>;</span><br><span class="line">  ht-&gt;pool = pool;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Lock. */</span></span><br><span class="line">  ht-&gt;lock = <span class="literal">NULL</span>;</span><br><span class="line">  ht-&gt;auto_delete_lock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the heap array.</span></span><br><span class="line">  <span class="comment">// 分配堆内存</span></span><br><span class="line">  ht-&gt;heap = (pj_timer_entry **)</span><br><span class="line">      pj_pool_alloc(pool, <span class="keyword">sizeof</span>(pj_timer_entry *) * <span class="built_in">size</span>);</span><br><span class="line">  <span class="keyword">if</span> (!ht-&gt;heap)</span><br><span class="line">    <span class="keyword">return</span> PJ_ENOMEM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the parallel</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  ht-&gt;timer_ids = (<span class="keyword">pj_timer_id_t</span> *)</span><br><span class="line">      pj_pool_alloc(pool, <span class="keyword">sizeof</span>(<span class="keyword">pj_timer_id_t</span>) * <span class="built_in">size</span>);</span><br><span class="line">  <span class="keyword">if</span> (!ht-&gt;timer_ids)</span><br><span class="line">    <span class="keyword">return</span> PJ_ENOMEM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the "freelist," which uses negative values to</span></span><br><span class="line">  <span class="comment">// distinguish freelist elements from "pointers" into the &lt;heap_&gt;</span></span><br><span class="line">  <span class="comment">// array.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">    ht-&gt;timer_ids[i] = -((<span class="keyword">pj_timer_id_t</span>)(i + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  *p_heap = ht;</span><br><span class="line">  <span class="keyword">return</span> PJ_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化状态，free_list=1,表示如果有entry加入进来，那么entry在heap堆的位置将记录在timer_ids[1]的位置。这里的lock并没有设置，所以可以为其配置lock.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PJ_DEF(<span class="keyword">void</span>)</span><br><span class="line">pj_timer_heap_set_lock(<span class="keyword">pj_timer_heap_t</span> *ht,</span><br><span class="line">                       <span class="keyword">pj_lock_t</span> *lock,</span><br><span class="line">                       <span class="keyword">pj_bool_t</span> auto_del)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (ht-&gt;lock &amp;&amp; ht-&gt;auto_delete_lock)</span><br><span class="line">    pj_lock_destroy(ht-&gt;lock);</span><br><span class="line"></span><br><span class="line">  ht-&gt;lock = lock;</span><br><span class="line">  ht-&gt;auto_delete_lock = auto_del;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pj-timer-entry-init"><a href="#pj-timer-entry-init" class="headerlink" title="pj_timer_entry_init()"></a>pj_timer_entry_init()</h4><p>初始化entry。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PJ_DEF(pj_timer_entry *)</span><br><span class="line">pj_timer_entry_init(pj_timer_entry *entry,</span><br><span class="line">                    <span class="keyword">int</span> id,</span><br><span class="line">                    <span class="keyword">void</span> *user_data,</span><br><span class="line">                    pj_timer_heap_callback *cb)</span><br><span class="line">&#123;</span><br><span class="line">  pj_assert(entry &amp;&amp; cb);</span><br><span class="line"></span><br><span class="line">  entry-&gt;_timer_id = <span class="number">-1</span>;</span><br><span class="line">  entry-&gt;id = id;</span><br><span class="line">  entry-&gt;user_data = user_data;</span><br><span class="line">  entry-&gt;cb = cb;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的_timer_id = -1，因为此时还没有插入到计时器堆里，所以设置为-1，其值代表该entry在timer_ids的下标位置。</p><h4 id="pj-timer-heap-schedule"><a href="#pj-timer-heap-schedule" class="headerlink" title="pj_timer_heap_schedule()"></a>pj_timer_heap_schedule()</h4><p>调度计时器，即将entry加入到计时器堆里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PJ_DEF(<span class="keyword">pj_status_t</span>)</span><br><span class="line">pj_timer_heap_schedule(<span class="keyword">pj_timer_heap_t</span> *ht,</span><br><span class="line">                       pj_timer_entry *entry,</span><br><span class="line">                       <span class="keyword">const</span> pj_time_val *<span class="built_in">delay</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pj_status_t</span> status;</span><br><span class="line">  pj_time_val expires;</span><br><span class="line"></span><br><span class="line">  PJ_ASSERT_RETURN(ht &amp;&amp; entry &amp;&amp; <span class="built_in">delay</span>, PJ_EINVAL);</span><br><span class="line">  PJ_ASSERT_RETURN(entry-&gt;cb != <span class="literal">NULL</span>, PJ_EINVAL);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Prevent same entry from being scheduled more than once */</span></span><br><span class="line">  PJ_ASSERT_RETURN(entry-&gt;_timer_id &lt; <span class="number">1</span>, PJ_EINVALIDOP);</span><br><span class="line"></span><br><span class="line">  pj_gettimeofday(&amp;expires);</span><br><span class="line">  PJ_TIME_VAL_ADD(expires, *<span class="built_in">delay</span>);</span><br><span class="line"></span><br><span class="line">  lock_timer_heap(ht);</span><br><span class="line">  status = schedule_entry(ht, entry, &amp;expires);</span><br><span class="line">  unlock_timer_heap(ht);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pj_gettimeofday</code>获取现在的时间给expires，<code>PJ_TIME_VAL_ADD</code>是现在的时间向后加delay的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pj_status_t</span> <span class="title">schedule_entry</span><span class="params">(<span class="keyword">pj_timer_heap_t</span> *ht,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  pj_timer_entry *entry,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> pj_time_val *future_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ht-&gt;cur_size &lt; ht-&gt;max_size)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Obtain the next unique sequence number.</span></span><br><span class="line">    <span class="comment">// Set the entry</span></span><br><span class="line">    entry-&gt;_timer_id = pop_freelist(ht);</span><br><span class="line">    entry-&gt;_timer_value = *future_time;</span><br><span class="line">    insert_node(ht, entry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pj_timer_id_t</span> <span class="title">pop_freelist</span><span class="params">(<span class="keyword">pj_timer_heap_t</span> *ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// We need to truncate this to &lt;int&gt; for backwards compatibility.</span></span><br><span class="line">  <span class="keyword">pj_timer_id_t</span> new_id = ht-&gt;timer_ids_freelist;</span><br><span class="line"></span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The freelist values in the &lt;timer_ids_&gt; are negative, so we need</span></span><br><span class="line">  <span class="comment">// to negate them to get the next freelist "pointer."</span></span><br><span class="line">  ht-&gt;timer_ids_freelist =</span><br><span class="line">      -ht-&gt;timer_ids[ht-&gt;timer_ids_freelist];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> new_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会将free_list赋值给entry的_timer_id,然后free_list等于timer_ids[free_list]的相反数，就是将free_list向后移一位。然后才开始将entry插入到堆里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_PARENT(X) (X == 0 ? 0 : (((X)-1) / 2))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(<span class="keyword">pj_timer_heap_t</span> *ht, pj_timer_entry *new_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ht-&gt;cur_size + <span class="number">2</span> &gt;= ht-&gt;max_size)</span><br><span class="line">    grow_heap(ht);</span><br><span class="line"></span><br><span class="line">  reheap_up(ht, new_node, ht-&gt;cur_size, HEAP_PARENT(ht-&gt;cur_size));</span><br><span class="line">  ht-&gt;cur_size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果堆大小不够了，那么将其扩展。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">grow_heap</span><span class="params">(<span class="keyword">pj_timer_heap_t</span> *ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// All the containers will double in size from max_size_</span></span><br><span class="line">  <span class="keyword">size_t</span> new_size = ht-&gt;max_size * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">pj_timer_id_t</span> *new_timer_ids;</span><br><span class="line">  <span class="keyword">pj_size_t</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First grow the heap itself.</span></span><br><span class="line"></span><br><span class="line">  pj_timer_entry **new_heap = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 复制heap，到新的heap</span></span><br><span class="line">  new_heap = (pj_timer_entry **)</span><br><span class="line">      pj_pool_alloc(ht-&gt;pool, <span class="keyword">sizeof</span>(pj_timer_entry *) * new_size);</span><br><span class="line">  <span class="built_in">memcpy</span>(new_heap, ht-&gt;heap, ht-&gt;max_size * <span class="keyword">sizeof</span>(pj_timer_entry *));</span><br><span class="line">  <span class="comment">//delete [] this-&gt;heap_;</span></span><br><span class="line">  <span class="comment">// 将原来heap指针指向new_heap</span></span><br><span class="line">  ht-&gt;heap = new_heap;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Grow the array of timer ids.</span></span><br><span class="line">  <span class="comment">// 复制timer_ids到新的tiemr_ids</span></span><br><span class="line">  new_timer_ids = <span class="number">0</span>;</span><br><span class="line">  new_timer_ids = (<span class="keyword">pj_timer_id_t</span> *)</span><br><span class="line">      pj_pool_alloc(ht-&gt;pool, new_size * <span class="keyword">sizeof</span>(<span class="keyword">pj_timer_id_t</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(new_timer_ids, ht-&gt;timer_ids, ht-&gt;max_size * <span class="keyword">sizeof</span>(<span class="keyword">pj_timer_id_t</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//delete [] timer_ids_;</span></span><br><span class="line">  ht-&gt;timer_ids = new_timer_ids;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// And add the new elements to the end of the "freelist".</span></span><br><span class="line">  <span class="comment">// 将新的timer_ids，从max_size初始化，设置为未分配的初始状态</span></span><br><span class="line">  <span class="keyword">for</span> (i = ht-&gt;max_size; i &lt; new_size; i++)</span><br><span class="line">    ht-&gt;timer_ids[i] = -((<span class="keyword">pj_timer_id_t</span>)(i + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  ht-&gt;max_size = new_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出这里扩展堆是将堆大小扩展到了之前的大小的两倍。</p><blockquote><p>这里仅仅只是将指针重新指向新的堆跟timer_ids，但是并没有将原来的内存释放掉。</p></blockquote><p>如果堆大小足够，那么就开始插入操作，reheap_up代表从堆的底部开始插入，然后根据规则进行向上调整移动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reheap_up</span><span class="params">(<span class="keyword">pj_timer_heap_t</span> *ht, pj_timer_entry *moved_node,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">size_t</span> slot, <span class="keyword">size_t</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Restore the heap property after an insertion.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (slot &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// If the parent node is greater than the &lt;moved_node&gt; we need</span></span><br><span class="line">    <span class="comment">// to copy it down.</span></span><br><span class="line">    <span class="keyword">if</span> (PJ_TIME_VAL_LT(moved_node-&gt;_timer_value, ht-&gt;heap[parent]-&gt;_timer_value))</span><br><span class="line">    &#123;</span><br><span class="line">      copy_node(ht, slot, ht-&gt;heap[parent]);</span><br><span class="line">      slot = parent;</span><br><span class="line">      parent = HEAP_PARENT(slot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert the new node into its proper resting place in the heap and</span></span><br><span class="line">  <span class="comment">// update the corresponding slot in the parallel &lt;timer_ids&gt; array.</span></span><br><span class="line">  copy_node(ht, slot, moved_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slot当前位置，parent代表父节点的位置，如果slot大于0意思就是当前的heap不为空那么进入循环，如果插入的entry的时间小于父节点，那么则跟父节点复制到slot的位置上，然后依次往上走，直到父节点的时间小于当前的entry，退出循环将entry复制到slot当前位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_node</span><span class="params">(<span class="keyword">pj_timer_heap_t</span> *ht, <span class="keyword">int</span> slot, pj_timer_entry *moved_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert &lt;moved_node&gt; into its new location in the heap.</span></span><br><span class="line">  ht-&gt;heap[slot] = moved_node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the corresponding slot in the parallel &lt;timer_ids_&gt; array.</span></span><br><span class="line">  ht-&gt;timer_ids[moved_node-&gt;_timer_id] = slot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这里将moved_node赋值给heap[slot],并且要更新timer_ids对entry的记录位置。</p><h4 id="pj-timer-heap-poll"><a href="#pj-timer-heap-poll" class="headerlink" title="pj_timer_heap_poll()"></a>pj_timer_heap_poll()</h4><p>轮询计时器堆并将过期的计时器移除，并进行回调，next_delay用来记录，移除后堆顶entry时间跟现在的时间差。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">PJ_DEF(<span class="keyword">unsigned</span>)</span><br><span class="line">pj_timer_heap_poll(<span class="keyword">pj_timer_heap_t</span> *ht,</span><br><span class="line">                   pj_time_val *next_delay)</span><br><span class="line">&#123;</span><br><span class="line">  pj_time_val now; <span class="comment">// 记录当前时间</span></span><br><span class="line">  <span class="keyword">unsigned</span> count; <span class="comment">// 过期entry的数量</span></span><br><span class="line"></span><br><span class="line">  PJ_ASSERT_RETURN(ht, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ht-&gt;cur_size &amp;&amp; next_delay)</span><br><span class="line">  &#123;</span><br><span class="line">    next_delay-&gt;sec = next_delay-&gt;msec = PJ_MAXINT32;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  count = <span class="number">0</span>; <span class="comment">// 初始化过期数量</span></span><br><span class="line">  pj_gettimeofday(&amp;now); <span class="comment">// 设置当前时间</span></span><br><span class="line"></span><br><span class="line">  lock_timer_heap(ht);</span><br><span class="line">  <span class="keyword">while</span> (ht-&gt;cur_size &amp;&amp;</span><br><span class="line">         PJ_TIME_VAL_LTE(ht-&gt;heap[<span class="number">0</span>]-&gt;_timer_value, now) &amp;&amp;</span><br><span class="line">         count &lt; ht-&gt;max_entries_per_poll)</span><br><span class="line">  &#123;</span><br><span class="line">    pj_timer_entry *node = remove_node(ht, <span class="number">0</span>);</span><br><span class="line">    ++count;</span><br><span class="line"></span><br><span class="line">    unlock_timer_heap(ht);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;cb)</span><br><span class="line">      (*node-&gt;cb)(ht, node);</span><br><span class="line">    lock_timer_heap(ht);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ht-&gt;cur_size &amp;&amp; next_delay)</span><br><span class="line">  &#123;</span><br><span class="line">    *next_delay = ht-&gt;heap[<span class="number">0</span>]-&gt;_timer_value;</span><br><span class="line">    PJ_TIME_VAL_SUB(*next_delay, now);</span><br><span class="line">    <span class="keyword">if</span> (next_delay-&gt;sec &lt; <span class="number">0</span> || next_delay-&gt;msec &lt; <span class="number">0</span>)</span><br><span class="line">      next_delay-&gt;sec = next_delay-&gt;msec = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (next_delay)</span><br><span class="line">  &#123;</span><br><span class="line">    next_delay-&gt;sec = next_delay-&gt;msec = PJ_MAXINT32;</span><br><span class="line">  &#125;</span><br><span class="line">  unlock_timer_heap(ht);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里移除entry，并进行了回调,这里next记录堆顶过期时间与现在的时间差。</p><blockquote><p>这里计算next_delay时间的时候，会判断时间是这里之所以会出现<code>next_delay-&gt;sec &lt; 0 || next_delay-&gt;msec &lt; 0</code>，因为设定了<code>max_entries_per_poll</code>，当移除了这么多entry后，也会跳出循环。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> pj_timer_entry *<span class="title">remove_node</span><span class="params">(<span class="keyword">pj_timer_heap_t</span> *ht, <span class="keyword">size_t</span> slot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pj_timer_entry *removed_node = ht-&gt;heap[slot];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return this timer id to the freelist.</span></span><br><span class="line">  <span class="comment">// 将freelist</span></span><br><span class="line">  push_freelist(ht, removed_node-&gt;_timer_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Decrement the size of the heap by one since we're removing the</span></span><br><span class="line">  <span class="comment">// "slot"th node.</span></span><br><span class="line">  <span class="comment">// 当前大小减一</span></span><br><span class="line">  ht-&gt;cur_size--;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the ID</span></span><br><span class="line">  <span class="comment">// 将entry的_timer_id重置</span></span><br><span class="line">  removed_node-&gt;_timer_id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Only try to reheapify if we're not deleting the last entry.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (slot &lt; ht-&gt;cur_size)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">    pj_timer_entry *moved_node = ht-&gt;heap[ht-&gt;cur_size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move the end node to the location being removed and update</span></span><br><span class="line">    <span class="comment">// the corresponding slot in the parallel &lt;timer_ids&gt; array.</span></span><br><span class="line">    copy_node(ht, slot, moved_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the &lt;moved_node-&gt;time_value_&gt; is great than or equal its</span></span><br><span class="line">    <span class="comment">// parent it needs be moved down the heap.</span></span><br><span class="line">    parent = HEAP_PARENT(slot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PJ_TIME_VAL_GTE(moved_node-&gt;_timer_value, ht-&gt;heap[parent]-&gt;_timer_value))</span><br><span class="line">      reheap_down(ht, moved_node, slot, HEAP_LEFT(slot));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      reheap_up(ht, moved_node, slot, parent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> removed_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将要移除的entry取出，然后将freelist的指向它并且将它的值设置为原free_list的相反数，这样下次加进来的entry会加入到该移除的位置，再下一个free_list又会回到原来的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">push_freelist</span><span class="params">(<span class="keyword">pj_timer_heap_t</span> *ht, <span class="keyword">pj_timer_id_t</span> old_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The freelist values in the &lt;timer_ids_&gt; are negative, so we need</span></span><br><span class="line">  <span class="comment">// to negate them to get the next freelist "pointer."</span></span><br><span class="line">  ht-&gt;timer_ids[old_id] = -ht-&gt;timer_ids_freelist;</span><br><span class="line">  ht-&gt;timer_ids_freelist = old_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置free_list之后，在将二叉树数组最后节点一个entry复制到该位置，然后开始移动根据父节点时间小于子节点时间的规则，如果该节点小于父节点，那么就往上移动，如果该节点大于父节点，那么该节点就往下判断跟自己的子节点比较，往下移动：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reheap_down</span><span class="params">(<span class="keyword">pj_timer_heap_t</span> *ht, pj_timer_entry *moved_node,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">size_t</span> slot, <span class="keyword">size_t</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restore the heap property after a deletion.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (child &lt; ht-&gt;cur_size)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Choose the smaller of the two children.</span></span><br><span class="line">    <span class="keyword">if</span> (child + <span class="number">1</span> &lt; ht-&gt;cur_size &amp;&amp; PJ_TIME_VAL_LT(ht-&gt;heap[child + <span class="number">1</span>]-&gt;_timer_value, ht-&gt;heap[child]-&gt;_timer_value))</span><br><span class="line">      child++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform a &lt;copy&gt; if the child has a larger timeout value than</span></span><br><span class="line">    <span class="comment">// the &lt;moved_node&gt;.</span></span><br><span class="line">    <span class="keyword">if</span> (PJ_TIME_VAL_LT(ht-&gt;heap[child]-&gt;_timer_value, moved_node-&gt;_timer_value))</span><br><span class="line">    &#123;</span><br><span class="line">      copy_node(ht, slot, ht-&gt;heap[child]);</span><br><span class="line">      slot = child;</span><br><span class="line">      child = HEAP_LEFT(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// We've found our location in the heap.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  copy_node(ht, slot, moved_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为子节点有两个，所以先比较两个子节点的大小，小的那个替代父节点，这样依次往下移动。</p><h4 id="pj-timer-heap-cancel"><a href="#pj-timer-heap-cancel" class="headerlink" title="pj_timer_heap_cancel()"></a>pj_timer_heap_cancel()</h4><p>取消计时器项，将其从计时器堆里移除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">PJ_DEF(<span class="keyword">int</span>) </span><br><span class="line">pj_timer_heap_cancel(<span class="keyword">pj_timer_heap_t</span> *ht,</span><br><span class="line">                     pj_timer_entry *entry)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">  PJ_ASSERT_RETURN(ht &amp;&amp; entry, PJ_EINVAL);</span><br><span class="line"></span><br><span class="line">  lock_timer_heap(ht);</span><br><span class="line">  count = cancel(ht, entry, <span class="number">1</span>);</span><br><span class="line">  unlock_timer_heap(ht);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cancel</span><span class="params">(<span class="keyword">pj_timer_heap_t</span> *ht,</span></span></span><br><span class="line"><span class="function"><span class="params">                  pj_timer_entry *entry,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> dont_call)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> timer_node_slot;</span><br><span class="line"></span><br><span class="line">  PJ_CHECK_STACK();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check to see if the timer_id is out of range</span></span><br><span class="line">  <span class="keyword">if</span> (entry-&gt;_timer_id &lt; <span class="number">0</span> || (<span class="keyword">pj_size_t</span>)entry-&gt;_timer_id &gt; ht-&gt;max_size)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 取出在heap的下标</span></span><br><span class="line">  timer_node_slot = ht-&gt;timer_ids[entry-&gt;_timer_id];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (timer_node_slot &lt; <span class="number">0</span>) <span class="comment">// Check to see if timer_id is still valid.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 比较两个地址是否一致（验证）</span></span><br><span class="line">  <span class="keyword">if</span> (entry != ht-&gt;heap[timer_node_slot])</span><br><span class="line">  &#123;</span><br><span class="line">    pj_assert(entry == ht-&gt;heap[timer_node_slot]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    remove_node(ht, timer_node_slot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dont_call == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// Call the close hook.</span></span><br><span class="line">      (*ht-&gt;callback)(ht, entry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的dont_call==0，则执行回调函数，否则不执行。</p><h4 id="pj-timer-heap-mem-size"><a href="#pj-timer-heap-mem-size" class="headerlink" title="pj_timer_heap_mem_size()"></a>pj_timer_heap_mem_size()</h4><p>计算计时器堆的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate memory size required to create a timer heap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PJ_DEF(<span class="keyword">pj_size_t</span>)</span><br><span class="line">pj_timer_heap_mem_size(<span class="keyword">pj_size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/* size of the timer heap itself: */</span></span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="keyword">pj_timer_heap_t</span>) +</span><br><span class="line">      <span class="comment">/* size of each entry: */</span></span><br><span class="line">      (count + <span class="number">2</span>) * (<span class="keyword">sizeof</span>(pj_timer_entry *) + <span class="keyword">sizeof</span>(<span class="keyword">pj_timer_id_t</span>)) +</span><br><span class="line">      <span class="comment">/* lock, pool etc: */</span></span><br><span class="line">      <span class="number">132</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体pj_timer_heap_t的大小，在加上(size+2)个entry指针的和timer_ids的大小，以及132用来lock等大小。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;PJSIP是一个开放源代码的SIP协议栈。它支持多种SIP的扩展功能，目前可说算是最流行的sip协议栈之一了。&lt;/p&gt;
&lt;h2 id=&quot;构成&quot;&gt;&lt;a href=&quot;#构成&quot; class=&quot;headerlink&quot; title=&quot;构成&quot;&gt;&lt;/a&gt;构成&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;PJSIP - Open Source SIP Stack[开源的SIP协议栈]&lt;/li&gt;
&lt;li&gt;PJMEDIA - Open Source Media Stack[开源的媒体栈]&lt;/li&gt;
&lt;li&gt;PJNATH - Open Source NAT Traversal Helper Library[开源的NAT-T辅助库]&lt;/li&gt;
&lt;li&gt;PJLIB-UTIL - Auxiliary Library[辅助工具库]&lt;/li&gt;
&lt;li&gt;PJLIB - Ultra Portable Base Framework Library[基础框架库]&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="study" scheme="http://veng.gitee.io/hexo/categories/study/"/>
    
    
      <category term="pjlib" scheme="http://veng.gitee.io/hexo/tags/pjlib/"/>
    
  </entry>
  
  <entry>
    <title>iframe自适应高度-跨域访问解决</title>
    <link href="http://veng.gitee.io/hexo/2020/04/29/iframe%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6-%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E8%A7%A3%E5%86%B3/"/>
    <id>http://veng.gitee.io/hexo/2020/04/29/iframe%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6-%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E8%A7%A3%E5%86%B3/</id>
    <published>2020-04-29T04:37:02.000Z</published>
    <updated>2020-12-08T05:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><code>iframe</code>内嵌其他项目的网页时(即跨域访问),会有自己的滚动条,并且高并不能自适应调整,预期得效果就好像<code>iframe</code>本身就是属于原页面的.</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>查找了许多资料,并没有一种便捷的解决方案.最后找到了<a href="http://davidjbradshaw.github.io/iframe-resizer/" target="_blank" rel="noopener">iFrame Resizer</a>,具体可以查看<a href="http://davidjbradshaw.github.io/iframe-resizer/" target="_blank" rel="noopener">官方文档</a>.</p><p>原网页:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">'内嵌的网页地址'</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">width</span>=<span class="string">"60%"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/iframe-resizer/4.1.1/iframeResizer.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">      iFrameResize(&#123;</span><br><span class="line"><span class="actionscript">        log: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">        checkOrigin: <span class="literal">false</span> </span></span><br><span class="line"><span class="actionscript">      &#125;, <span class="string">'#iframe'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>内嵌网页,头部引入:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.4.1/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/iframe-resizer/4.1.1/iframeResizer.contentWindow.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意: <code>iframe</code>必须引入<code>jQuery</code>,两个地方都要,因为它是基于<code>jQuery</code>实现的,</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;iframe&lt;/code&gt;内嵌其他项目的网页时(即跨域访问),会有自己的滚动条,并且高并不能自适应调整,预期得效果就好像&lt;code&gt;iframe&lt;/code&gt;本身就是属于原页面的.&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://veng.gitee.io/hexo/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="iframe" scheme="http://veng.gitee.io/hexo/tags/iframe/"/>
    
      <category term="跨域" scheme="http://veng.gitee.io/hexo/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>git 命令</title>
    <link href="http://veng.gitee.io/hexo/2020/04/11/git/"/>
    <id>http://veng.gitee.io/hexo/2020/04/11/git/</id>
    <published>2020-04-11T10:19:04.000Z</published>
    <updated>2020-12-08T05:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-命令-持续更新"><a href="#git-命令-持续更新" class="headerlink" title="git 命令 持续更新"></a>git 命令 持续更新</h2><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><p>切换分支,创建分支</p><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout new_branch_name</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="创建新分支并切换到该分支上"><a href="#创建新分支并切换到该分支上" class="headerlink" title="创建新分支并切换到该分支上"></a>创建新分支并切换到该分支上</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new_branch_name</span><br></pre></td></tr></table></figure><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>将工作区的文件加入到暂存区.</p><h4 id="将目录下所有文件加入到暂存区"><a href="#将目录下所有文件加入到暂存区" class="headerlink" title="将目录下所有文件加入到暂存区"></a>将目录下所有文件加入到暂存区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>后面加上一个点，表示当前目录下所有文件.</p><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>将暂存区里的文件，提交到版本库里.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m '提交的信息'</span><br></pre></td></tr></table></figure><h3 id="reset命令"><a href="#reset命令" class="headerlink" title="reset命令"></a>reset命令</h3><p>一般用来撤销commit操作,回退到某个版本.</p><p>有三种撤销模式:</p><ul><li>soft</li><li>hard</li><li>mixed</li></ul><h4 id="soft"><a href="#soft" class="headerlink" title="soft"></a>soft</h4><p>不删除工作空间改动代码，撤销commit，不撤销git add</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft &lt;版本号&gt;</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 回退到上一个版本</span></span><br><span class="line">git reset --soft HEAD^ </span><br><span class="line">or</span><br><span class="line">git reset --soft HEAD~1 # 后面的数字表示,回退的几步</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回退到指定版本</span></span><br><span class="line">git reset --soft fdf9172625980ff6d754238ed08d182806823972</span><br></pre></td></tr></table></figure><h4 id="hard-谨慎操作"><a href="#hard-谨慎操作" class="headerlink" title="hard (谨慎操作)"></a>hard (谨慎操作)</h4><p><strong><font color="red">删除工作空间改动代码</font></strong>，撤销commit，撤销git add,注意完成这个操作后，就恢复到了上一次的commit状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;版本号&gt;</span><br></pre></td></tr></table></figure><p>如果误操作了,请看<a href="#reset-误操作" target="_parent">reset误操作</a></p><h4 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h4><p>不删除工作空间改动代码，撤销commit，并且撤销 git add 操作,这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [--mixed] &lt;版本号&gt;</span><br></pre></td></tr></table></figure><h3 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a>rm 命令</h3><p>用于从索引中删除文件或者同时从工作区和索引中删除文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm [-r] &lt;path&gt;</span><br></pre></td></tr></table></figure><p>-r 如果是删除文件夹则加上此参数,跟linux命令一致.</p><h4 id="rm-–-cached"><a href="#rm-–-cached" class="headerlink" title="rm –-cached"></a>rm –-cached</h4><p>从索引中删除文件。但是本地文件还存在， 只是不希望这个文件被版本控制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached [-r] &lt;path&gt;</span><br></pre></td></tr></table></figure><h3 id="比较本地与远程的差异"><a href="#比较本地与远程的差异" class="headerlink" title="比较本地与远程的差异"></a>比较本地与远程的差异</h3><h4 id="comment-差异"><a href="#comment-差异" class="headerlink" title="comment 差异"></a>comment 差异</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log master..origin/master</span><br></pre></td></tr></table></figure><h4 id="文件改动"><a href="#文件改动" class="headerlink" title="文件改动"></a>文件改动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git diff &lt;<span class="built_in">local</span> branch&gt; &lt;remote&gt;/&lt;remote branch&gt;</span></span><br><span class="line">git diff --stat master origin/master</span><br></pre></td></tr></table></figure><h3 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h3><h4 id="与远程仓库建立关联"><a href="#与远程仓库建立关联" class="headerlink" title="与远程仓库建立关联"></a>与远程仓库建立关联</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:xxxx/xxx.git</span><br></pre></td></tr></table></figure><h4 id="推送到远程分支"><a href="#推送到远程分支" class="headerlink" title="推送到远程分支"></a>推送到远程分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一次推送</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以后推送</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h4 id="解除与远程仓库的关联"><a href="#解除与远程仓库的关联" class="headerlink" title="解除与远程仓库的关联"></a>解除与远程仓库的关联</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure><h4 id="推送到远程指定分支"><a href="#推送到远程指定分支" class="headerlink" title="推送到远程指定分支"></a>推送到远程指定分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;localBranchName&gt;:&lt;remoteBranchName&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果远程分支与本地分支名字一样,则写一个就行</span></span><br><span class="line">git push origin &lt;branchName&gt;</span><br></pre></td></tr></table></figure><h4 id="查看远程分支详细信息"><a href="#查看远程分支详细信息" class="headerlink" title="查看远程分支详细信息"></a>查看远程分支详细信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote_branch_name]</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><p><img src="http://veng.gitee.io/hexo/2020/04/11/git/assets/1586608096243.png" alt="1586608096243"></p><h3 id="tag-标签"><a href="#tag-标签" class="headerlink" title="tag 标签"></a>tag 标签</h3><p>像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ <code>v1.0</code> 、 <code>v2.0</code> 等等）。</p><h4 id="列举标签"><a href="#列举标签" class="headerlink" title="列举标签"></a>列举标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）.</p><h5 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &#123;version_name&#125;</span><br></pre></td></tr></table></figure><h5 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h5><p>也就是对改标签有了一个标注说明.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &#123;version_name&#125; -m "对该标签的说明以及标注"</span><br></pre></td></tr></table></figure><h5 id="查看标签信息"><a href="#查看标签信息" class="headerlink" title="查看标签信息"></a>查看标签信息</h5><p>然后我们可以查看当时标签的信息以及提交的信息.</p><p>示例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show v1.4</span></span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure><p>此时中间那个是标签的标注说明,后面是当时的<code>commit</code>的信息.而轻量标签则没有中间的标注说明.</p><h3 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h3><h4 id="reset-hard-误操作-回到以前的版本了"><a href="#reset-hard-误操作-回到以前的版本了" class="headerlink" title="reset --hard 误操作 回到以前的版本了"></a><span id="reset-误操作"><code>reset --hard</code> 误操作 回到以前的版本了</span></h4><p>发现 <code>git log</code>没有之后的版本信息，那么在哪里找呢？</p><p>可以在 <code>.git</code>目录下找到，<code>.git\logs\refs\heads</code></p><p>示例：</p><p><img src="http://veng.gitee.io/hexo/2020/04/11/git/assets/1584365274469.png" alt="1584365274469"></p><p>以上是创建的分支.,打开就能看见各个版本的提交信息，找你想恢复版本的版本号.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 你的版本号</span><br></pre></td></tr></table></figure><p>这样就可以回到你想回到的版本，这个会保存30天，注意要及时。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;git-命令-持续更新&quot;&gt;&lt;a href=&quot;#git-命令-持续更新&quot; class=&quot;headerlink&quot; title=&quot;git 命令 持续更新&quot;&gt;&lt;/a&gt;git 命令 持续更新&lt;/h2&gt;&lt;h3 id=&quot;checkout&quot;&gt;&lt;a href=&quot;#checkout&quot; class=&quot;headerlink&quot; title=&quot;checkout&quot;&gt;&lt;/a&gt;checkout&lt;/h3&gt;&lt;p&gt;切换分支,创建分支&lt;/p&gt;
&lt;h4 id=&quot;切换分支&quot;&gt;&lt;a href=&quot;#切换分支&quot; class=&quot;headerlink&quot; title=&quot;切换分支&quot;&gt;&lt;/a&gt;切换分支&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout new_branch_name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="其他" scheme="http://veng.gitee.io/hexo/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="git" scheme="http://veng.gitee.io/hexo/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer笔试题</title>
    <link href="http://veng.gitee.io/hexo/2020/04/10/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://veng.gitee.io/hexo/2020/04/10/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-10T08:28:39.000Z</published>
    <updated>2020-12-08T05:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指Offer-编程题"><a href="#剑指Offer-编程题" class="headerlink" title="剑指Offer_编程题"></a>剑指Offer_编程题</h2><h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><p><strong>题目描述：</strong></p><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">原题链接</a></p><a id="more"></a><p>例子：</p><p>输入：</p><p>target : 9</p><p>1，2，4，5，</p><p>3，4，6，8，</p><p>4，7，8，10，</p><p>5，8，9，11，</p><p>7，11，12，14，</p><p>输出： true</p><h4 id="Java解题："><a href="#Java解题：" class="headerlink" title="Java解题："></a><strong>Java解题：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> rows = array.length;</span><br><span class="line">  <span class="keyword">int</span> columns = array[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>,column = columns - <span class="number">1</span>;row&lt;=rows-<span class="number">1</span>&amp;&amp;column&gt;=<span class="number">0</span>;)&#123;</span><br><span class="line">    <span class="keyword">int</span> number = array[row][column];</span><br><span class="line">    <span class="keyword">if</span> (number == target) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(number &lt; target)&#123;</span><br><span class="line">        row+=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(number &gt; target)&#123;</span><br><span class="line">      column-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路</strong>：</h4><ol><li>首先判断数组是否是空数组，类似这种 <code>[],[[]]</code>,排除以上情况，</li><li>然后我们考虑正常的二维数组，思考先从哪里开始判断，从左上角开始，或者从右上角，左下角，或者右下角，左上角的数是最小的，右下角的数是最大的，我选择的是从右上角开始判断，这样可以先判断目标数在哪一行。</li><li>如果大于这样最右边的数，则不会在这一行出现，那么就开始判断下一行，如果小于最右边的数，则有可能出现在这样一行，故往左边移动。</li><li>如果在往左移的途中没有找到该数，一直找到一个小于它的数，则说明该数只可能出现在该列，故而往下一行继续找，直至找到它为止。</li></ol><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">原题链接</a>。</p><h4 id="Java解题"><a href="#Java解题" class="headerlink" title="Java解题"></a><strong>Java解题</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">  int val;</span></span><br><span class="line"><span class="comment">  TreeNode left;</span></span><br><span class="line"><span class="comment">  TreeNode right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  TreeNode(int x) &#123;</span></span><br><span class="line"><span class="comment">    val = x;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || pre.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> root = pre[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] == root) &#123;</span><br><span class="line">          rootIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span>[] leftFront = <span class="keyword">new</span> <span class="keyword">int</span>[rootIndex];</span><br><span class="line">      <span class="keyword">int</span>[] leftIn = <span class="keyword">new</span> <span class="keyword">int</span>[rootIndex];</span><br><span class="line">      <span class="keyword">int</span>[] rightFront = <span class="keyword">new</span> <span class="keyword">int</span>[in.length - rootIndex - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">int</span>[] rightIn = <span class="keyword">new</span> <span class="keyword">int</span>[in.length - rootIndex - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leftFront.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; pre.length) &#123;</span><br><span class="line">          leftFront[i] = pre[i + <span class="number">1</span>];</span><br><span class="line">          leftIn[i] = in[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          leftFront = <span class="keyword">null</span>;</span><br><span class="line">          leftIn = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rightFront.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rootIndex + <span class="number">1</span> + i &lt; in.length) &#123;</span><br><span class="line">          rightIn[i] = in[rootIndex + <span class="number">1</span> + i];</span><br><span class="line">          rightFront[i] = pre[rootIndex + <span class="number">1</span> + i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          rightFront = <span class="keyword">null</span>;</span><br><span class="line">          rightIn = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      TreeNode rootTree = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">      rootTree.left = reConstructBinaryTree(leftFront, leftIn);</span><br><span class="line">      rootTree.right = reConstructBinaryTree(rightFront, rightIn);</span><br><span class="line">      <span class="keyword">return</span> rootTree;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>首先想到的是递归的方法遍历二叉树，发挥想象力，将一个二叉树看成是由一个根节点，和左子树右子树组成，将左子树也看成是一个二叉树，也有根节点和左右子树，每个子树都这样想象，然后最后会到二叉树的最后，根节点没有子树了，这是递归的过程。</li><li>然后考虑，提供的前序遍历和中序遍历，先选出根节点，前序遍历的第一个数一定是根节点，如例子中的<code>1</code>，在看中序遍历数组中，在根节点数左边的数<code>4,7,2</code>是左子树上的数，在根节点右边的数<code>5,3,8,6</code>是右子树上的数，然后分别将两个子树看成是一个二叉树，进行递归，直至最后没有子树，数组的大小等于1，返回该节点。</li></ol><h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><p>题目描述：</p><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">原题链接</a></p><h4 id="Java解题-1"><a href="#Java解题-1" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">  Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    stack1.add(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer temp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(stack1.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">      temp = stack1.pop();</span><br><span class="line">      stack2.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    stack2.pop();</span><br><span class="line">    <span class="keyword">while</span>(stack2.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">      stack1.add(stack2.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>对于加进来的数，则直接压入栈中。</li><li>对于移出队列，则就是将栈底的那个数移出，所以要先将上面的数移出栈保存，再将栈底的数移出，然后再将之前的数放回栈。</li></ol><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>题目描述：</p><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p><p>n&lt;=39.</p><p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">原题链接</a></p><h4 id="Java解题-2"><a href="#Java解题-2" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>)+fibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>递归解题，数列从第2项起，每一个项都是前两项得和，故而<code>n=0 or n=1</code>的时候，才返回<code>n</code>,其他情况都返回前两项之和。</p><h3 id="跳台阶（青蛙"><a href="#跳台阶（青蛙" class="headerlink" title="跳台阶（青蛙) "></a><span id="frog">跳台阶（青蛙) </span></h3><p>题目描述：</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">原题链接</a></p><h4 id="Java解题-3"><a href="#Java解题-3" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target == <span class="number">1</span>|| target == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>)+JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>青蛙每次只能跳一级或者两级，那么最后一次跳到<code>n级台阶</code>，要么跳一级要么跳两级，所以两个加起来就是所有的可能，然后跳一级就考虑，跳到<code>n-1级台阶</code>，有多少种可能，同理跟跳到<code>n级</code>时一样考虑，这样最后当<code>n</code>减到<code>1</code>或者<code>0</code>级时，只有一种可能就返回<code>1</code>.</p><h3 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h3><p>题目描述：</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">原题链接</a></p><h4 id="Java解题-4"><a href="#Java解题-4" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;target;i++)&#123;</span><br><span class="line">    result += JumpFloorII(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>跟之前一样考虑，考虑最后一步是跳了几级，之前只要将最后一步跳一级跟跳两级的加起来，现在是要把最后跳<code>1级</code>到最后跳<code>n-1级</code>的全部加起来，最后加上一次性全跳完的。</p><h3 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h3><p>题目描述：</p><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">原题链接</a></p><p>比如n=3时，2*3的矩形块有3种覆盖方法：</p><p><img src="http://veng.gitee.io/hexo/2020/04/10/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AF%95%E9%A2%98/assets/6384065_1581999858239_64E40A35BE277D7E7C87D4DCF588BE84.png" alt="img"></p><h4 id="Java解题-5"><a href="#Java解题-5" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> assist(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">assist</span><span class="params">(<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target == <span class="number">1</span>|| target == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> assist(target-<span class="number">1</span>)+assist(target-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个跟之前的青蛙跳台阶问题一模一样，唯一一点特殊就是n可以等于0，所以要单独拿出来，其他情况可以跟青蛙台阶一样考虑，也是考虑最后一次是横放（2级台阶）还是竖放（一级台阶），然后将两种可能加起来就是了，可以参考<a href="#frog">青蛙跳台阶</a>。</p><h3 id="二进制1的个数"><a href="#二进制1的个数" class="headerlink" title="二进制1的个数"></a>二进制1的个数</h3><p>题目描述：</p><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">原题链接</a></p><h4 id="Java解题-6"><a href="#Java解题-6" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">    count++;</span><br><span class="line">    n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先在计算机中，计算过程都是用补码进行的， 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 比如<code>1100</code>,我们要数1的个数，可以一个个1数，从最后的1开始，对齐减一后，<code>1011</code>,两数进行与运算后，得到<code>1000</code>，这样正好少了最后的1，这样循环运算，直至没有1为止，得到1的个数。</p><h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><p>题目描述：</p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tPage=1" target="_blank" rel="noopener">原题链接</a></p><h4 id="Java解题-7"><a href="#Java解题-7" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] odd = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line"><span class="keyword">int</span>[] even = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line"><span class="keyword">int</span> odd_index = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> even_index = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> mod = array[i] % <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> ( mod == <span class="number">1</span> ) &#123;</span><br><span class="line">    odd[odd_index++] = array[i];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    even[even_index++] = array[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; odd_index; i++) &#123;</span><br><span class="line">  array[i] = odd[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; even_index; i++) &#123;</span><br><span class="line">  array[i+odd_index] = even[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h4><p>就是利用两个数组来分别存储奇数和偶数，然后再赋值给array。</p><h3 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h3><p>题目描述：</p><p>输入一个链表，输出该链表中倒数第k个结点。</p><p><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tPage=1" target="_blank" rel="noopener">原题链接</a></p><h4 id="Java解题-8"><a href="#Java解题-8" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span> || k == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ArrayList&lt;ListNode&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    temp.add(head);</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> index = temp.size() - k;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> temp.get(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h4><p>有几种特殊情况，<code>链表为空</code>，<code>k=0</code>，以及<code>k&gt;链表长度</code>，其他情况可以，将每个节点存储到<code>ArrayList</code>，然后取出对应的节点。</p><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>题目描述：</p><p>输入一个链表，反转链表后，输出新链表的表头。</p><p><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">原题链接</a></p><h4 id="Java解题-9"><a href="#Java解题-9" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode now = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    ListNode pre = now;</span><br><span class="line">    now = head;</span><br><span class="line">    now.next = pre;</span><br><span class="line">    head = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h4><p>先记录当前节点的下一个节点，然后将当前节点指向前一个节点。</p><p><img src="http://veng.gitee.io/hexo/2020/04/10/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AF%95%E9%A2%98/assets/1582621779438.png" alt="1582621779438"></p><p><img src="http://veng.gitee.io/hexo/2020/04/10/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AF%95%E9%A2%98/assets/1582621789241.png" alt="1582621789241"></p><p><img src="http://veng.gitee.io/hexo/2020/04/10/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AF%95%E9%A2%98/assets/1582621830470.png" alt="1582621830470"></p><h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h3><p>题目描述：</p><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tPage=1" target="_blank" rel="noopener">原题链接</a></p><h4 id="Java解题-10"><a href="#Java解题-10" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list1;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode temp = result;</span><br><span class="line">  <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> first = list1.val;</span><br><span class="line">    <span class="keyword">int</span> second = list2.val;</span><br><span class="line">    <span class="keyword">if</span> (first&lt;=second) &#123;</span><br><span class="line">      temp.next = list1;</span><br><span class="line">      list1 = list1.next;</span><br><span class="line">      </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      temp.next = list2;</span><br><span class="line">      list2 = list2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = temp.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (list1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    temp.next = list1;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    temp.next = list2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h4><p>因为最后返回链表的头部，所以先新建一个指向头的节点<code>new ListNode(0)</code>，然后比较大小，优先指向小的，最后直到，有一个链表为<code>null</code>，退出循环，如果然后最后指向不为空的另一个条链表。</p><h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><p>题目描述：</p><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tPage=1" target="_blank" rel="noopener">原题链接</a></p><h4 id="Java解题-11"><a href="#Java解题-11" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subTree(root1, root2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">subTree</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root1.val == root2.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> subTree(root1.left,root2.left) &amp;&amp; subTree(root1.right,root2.right)||</span><br><span class="line">    subTree(root1.left, root2)|| subTree(root1.right,root2);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subTree(root1.left, root2)|| subTree(root1.right,root2);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h4><p>首先将题目中所说的空树不是任意一个树的子结构，判断，然后进行递归遍历，如果出现节点相等点，那么继续判断它的子节点是否均相等<code>subTree(root1.left,root2.left) &amp;&amp; subTree(root1.right,root2.right)</code>，相等的节点的子树可能跟要求的子树一样，所以还要判断相等节点的子节点是否可能出现子结构<code>subTree(root1.left,root2.left) &amp;&amp; subTree(root1.right,root2.right)||      subTree(root1.left, root2)|| subTree(root1.right,root2);</code>,如果子节点不相等，那么就继续判断子节点。到<code>root2</code>为<code>null</code>了那么此时肯定是<code>root2</code>的子节点全都判断过了相等，如果<code>root1</code>为空了，但是<code>root2</code>不为空，这可以肯定不是子结构。</p><h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><p>题目描述</p><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p><strong>输入描述:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">        8</span><br><span class="line">       /  \</span><br><span class="line">      6   10</span><br><span class="line">     / \  / \</span><br><span class="line">    5  7 9 11</span><br><span class="line">    镜像二叉树</span><br><span class="line">        8</span><br><span class="line">       /  \</span><br><span class="line">      10   6</span><br><span class="line">     / \  / \</span><br><span class="line">    11 9 7  5</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tPage=1" target="_blank" rel="noopener">原题链接</a></p><h4 id="Java解题-12"><a href="#Java解题-12" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TreeNode left = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    Mirror(root.left);</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h4><p>还是利用递归遍历，先将根节点的左右子树交换，然后对左节点和右节点递归遍历交换，这样就都交换了，将左右子树看成是一个点，然后再将这个点看成一颗树递归。</p><h3 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h3><p>题目描述</p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p>例如，如果输入如下4 X 4矩阵： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4</span><br><span class="line">5, 6, 7, 8 </span><br><span class="line">9, 10, 11, 12 </span><br><span class="line">13, 14, 15, 16</span><br></pre></td></tr></table></figure><p>则依次打印出数字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">原题链接</a>.</p><h4 id="Java解题-13"><a href="#Java解题-13" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rows = matrix.length;</span><br><span class="line"><span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span> min = rows&gt;columns?columns:rows;</span><br><span class="line"><span class="keyword">int</span> loop = (min / <span class="number">2</span>) + (min % <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> column = <span class="number">0</span>;</span><br><span class="line">ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; loop; l++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row,j = column; j &lt; columns; j++) &#123;</span><br><span class="line">    result.add(matrix[i][j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row + <span class="number">1</span>,j = columns - <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    result.add(matrix[i][j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = rows - <span class="number">1</span>,j = columns - <span class="number">2</span>; j&gt;=row &amp;&amp; i &gt; row; j--) &#123;</span><br><span class="line">    result.add(matrix[i][j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = rows - <span class="number">2</span>,j = column; i&gt;row &amp;&amp; columns!=<span class="number">1</span>;i--) &#123;</span><br><span class="line">    result.add(matrix[i][j]);</span><br><span class="line">  &#125;</span><br><span class="line">  row++;</span><br><span class="line">  column++;</span><br><span class="line">  rows-=<span class="number">1</span>;</span><br><span class="line">  columns-=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><h4 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h4><p>可以想象成绕圈，每次重复的部分就是一圈，横竖横竖，循环即可，至于转多少圈可以计算出来就是，矩形短的一边除于2，</p><h3 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h3><p>题目描述:</p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">原题链接</a>.</p><h4 id="Java解题-14"><a href="#Java解题-14" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span>[] pushA, <span class="keyword">int</span>[] popA)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ArrayList&lt;Integer&gt; temp_list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> pushA_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> popA_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pushA_index &lt; pushA.length) &#123;</span><br><span class="line">      temp_list.add(pushA[pushA_index++]);</span><br><span class="line">      <span class="keyword">while</span> (popA_index &lt; popA.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> popNum = popA[popA_index];</span><br><span class="line">        <span class="keyword">int</span> d = temp_list.indexOf(popNum);</span><br><span class="line">        <span class="keyword">if</span> (d != -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (d == temp_list.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            temp_list.remove(d);</span><br><span class="line">            popA_index++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp_list.size() == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先要理解该题的入栈出栈,我之前一直以为是全部压栈再出栈,实际上是一边压栈一边出栈.</p><p>然后就可以解题了,先一个一个数压栈,并一边判断出栈数组中的第一个数是否为压栈元素,如果不是则继续压栈,如果是则栈顶元素出栈并继续判断出栈数组中的下个数是否为栈顶元素.最后如果栈是空的话,说明该出栈数组是正确的,如果不过空,则说明该数组不正确.</p><h3 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h3><p>题目描述:</p><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">原题链接</a>.</p><h4 id="Java解题-15"><a href="#Java解题-15" class="headerlink" title="Java解题"></a>Java解题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    add(result, queue);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ArrayList&lt;Integer&gt; list, Queue&lt;TreeNode&gt; queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      TreeNode temp = queue.remove();</span><br><span class="line">      <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(temp.val);</span><br><span class="line">        queue.add(temp.left);</span><br><span class="line">        queue.add(temp.right);</span><br><span class="line">      &#125;</span><br><span class="line">      add(list, queue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先想到用队列来存储节点信息,然后先进先出来读取节点,这样就一层一层读取了.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;剑指Offer-编程题&quot;&gt;&lt;a href=&quot;#剑指Offer-编程题&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer_编程题&quot;&gt;&lt;/a&gt;剑指Offer_编程题&lt;/h2&gt;&lt;h3 id=&quot;二维数组中的查找&quot;&gt;&lt;a href=&quot;#二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;二维数组中的查找&quot;&gt;&lt;/a&gt;二维数组中的查找&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法题" scheme="http://veng.gitee.io/hexo/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="http://veng.gitee.io/hexo/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离合并配置</title>
    <link href="http://veng.gitee.io/hexo/2020/04/09/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%90%88%E5%B9%B6%E9%85%8D%E7%BD%AE/"/>
    <id>http://veng.gitee.io/hexo/2020/04/09/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%90%88%E5%B9%B6%E9%85%8D%E7%BD%AE/</id>
    <published>2020-04-09T08:43:31.000Z</published>
    <updated>2020-12-08T05:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前后端分离合并配置"><a href="#前后端分离合并配置" class="headerlink" title="前后端分离合并配置"></a>前后端分离合并配置</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>以<code>react</code>前端为例,用的<code>http</code>库是<code>axios</code>.后端用的是<code>eggjs</code>框架.</p><a id="more"></a><h3 id="前后端分离跨域配置"><a href="#前后端分离跨域配置" class="headerlink" title="前后端分离跨域配置"></a>前后端分离跨域配置</h3><h4 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h4><p>在项目的<code>package.json</code>里配置代理: </p><p>示例:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...,</span><br><span class="line">    "proxy": "http://localhost:7001"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在添加 <code>x-csrf-token</code>请求头:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">'./axios'</span>;</span><br><span class="line"><span class="keyword">import</span> cookie <span class="keyword">from</span> <span class="string">'react-cookies'</span>;</span><br><span class="line">http.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 配置跨域请求</span></span><br><span class="line">  config.headers[<span class="string">'x-csrf-token'</span>] = cookie.load(<span class="string">'csrfToken'</span>);</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>该token在cookie里,将它取出然后将其放到<code>x-csrf-token</code>里.验证时,要查看发送请求的头里是否有该字段.</p><p>示例:</p><p><img src="http://veng.gitee.io/hexo/2020/04/09/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%90%88%E5%B9%B6%E9%85%8D%E7%BD%AE/assets/1586583272298.png" alt="1586583272298"></p><h4 id="后端配置"><a href="#后端配置" class="headerlink" title="后端配置"></a>后端配置</h4><p>后端无需额外的配置.</p><h3 id="前后端合并"><a href="#前后端合并" class="headerlink" title="前后端合并"></a>前后端合并</h3><h4 id="前端配置-1"><a href="#前端配置-1" class="headerlink" title="前端配置"></a>前端配置</h4><p>前端将之间的代理去掉.</p><p>但是那个请求头的配置不能去掉,这是<code>eggjs</code>内置的跨域防范策略配置,删去之后是无法请求成功的.</p><p><a href="https://eggjs.org/zh-cn/core/security.html#%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81-csrf-%E7%9A%84%E9%98%B2%E8%8C%83" target="_blank" rel="noopener">详情请看官网说明</a>.</p><h4 id="后端配置-1"><a href="#后端配置-1" class="headerlink" title="后端配置"></a>后端配置</h4><p>前端打包后,将<code>index.html</code>等<code>html</code>文件放到<code>eggjs</code>项目的<code>app/view</code>,将其他<code>css</code>,<code>js</code>,<code>json</code>等静态资源文件均放到<code>app/public</code>下.</p><p>目录结构示例:</p><p><img src="http://veng.gitee.io/hexo/2020/04/09/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%90%88%E5%B9%B6%E9%85%8D%E7%BD%AE/assets/1586421552205.png" alt="1586421552205"></p><h5 id="安装模板渲染插件"><a href="#安装模板渲染插件" class="headerlink" title="安装模板渲染插件"></a>安装模板渲染插件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save egg-view-nunjucks</span><br></pre></td></tr></table></figure><h5 id="启用插件"><a href="#启用插件" class="headerlink" title="启用插件"></a>启用插件</h5><p><code>config/plugin.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...,</span><br><span class="line">    nunjucks: &#123;</span><br><span class="line">    enable: <span class="literal">true</span>,</span><br><span class="line">    package: <span class="string">'egg-view-nunjucks'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="配置模板渲染引擎与静态资源文件"><a href="#配置模板渲染引擎与静态资源文件" class="headerlink" title="配置模板渲染引擎与静态资源文件"></a>配置模板渲染引擎与静态资源文件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">appInfo</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 根据后缀去找相应的模板引擎</span></span><br><span class="line">config.view = &#123;</span><br><span class="line">mapping: &#123;</span><br><span class="line"><span class="string">'.html'</span>: <span class="string">'nunjucks'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 静态资源配置</span></span><br><span class="line">    config.static = &#123;</span><br><span class="line">    prefix: <span class="string">'/'</span>,</span><br><span class="line">    dir: path.join(appInfo.baseDir, <span class="string">'app/public'</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="controller渲染html"><a href="#controller渲染html" class="headerlink" title="controller渲染html"></a>controller渲染<code>html</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">'egg'</span>).Controller;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> index() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'index.html'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前后端分离合并配置&quot;&gt;&lt;a href=&quot;#前后端分离合并配置&quot; class=&quot;headerlink&quot; title=&quot;前后端分离合并配置&quot;&gt;&lt;/a&gt;前后端分离合并配置&lt;/h2&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;以&lt;code&gt;react&lt;/code&gt;前端为例,用的&lt;code&gt;http&lt;/code&gt;库是&lt;code&gt;axios&lt;/code&gt;.后端用的是&lt;code&gt;eggjs&lt;/code&gt;框架.&lt;/p&gt;
    
    </summary>
    
    
      <category term="后台" scheme="http://veng.gitee.io/hexo/categories/%E5%90%8E%E5%8F%B0/"/>
    
      <category term="前端" scheme="http://veng.gitee.io/hexo/categories/%E5%90%8E%E5%8F%B0/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react" scheme="http://veng.gitee.io/hexo/tags/react/"/>
    
      <category term="nodejs" scheme="http://veng.gitee.io/hexo/tags/nodejs/"/>
    
      <category term="eggjs" scheme="http://veng.gitee.io/hexo/tags/eggjs/"/>
    
      <category term="axios" scheme="http://veng.gitee.io/hexo/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://veng.gitee.io/hexo/2020/04/08/mysql/"/>
    <id>http://veng.gitee.io/hexo/2020/04/08/mysql/</id>
    <published>2020-04-08T10:22:04.000Z</published>
    <updated>2020-12-08T05:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="create-指令"><a href="#create-指令" class="headerlink" title="create 指令"></a>create 指令</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [database_name.]table_name (column_name column_type ,...,primary <span class="keyword">key</span>(column_name,...));</span><br></pre></td></tr></table></figure><h3 id="select-指令"><a href="#select-指令" class="headerlink" title="select 指令"></a>select 指令</h3><h4 id="查询某表指定列数据"><a href="#查询某表指定列数据" class="headerlink" title="查询某表指定列数据"></a>查询某表指定列数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,...  <span class="keyword">from</span> [database_name.]table_name;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="查询某表全部列数据"><a href="#查询某表全部列数据" class="headerlink" title="查询某表全部列数据"></a>查询某表全部列数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> [database_name.]table_name;</span><br></pre></td></tr></table></figure><h3 id="update-指令"><a href="#update-指令" class="headerlink" title="update 指令"></a>update 指令</h3><h4 id="修改某表的数据符合条件的数据"><a href="#修改某表的数据符合条件的数据" class="headerlink" title="修改某表的数据符合条件的数据"></a>修改某表的数据符合条件的数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> [database_name.]table_name <span class="keyword">set</span> column_name=new_value,... [<span class="keyword">where</span> clause]</span><br></pre></td></tr></table></figure><h3 id="delete-指令"><a href="#delete-指令" class="headerlink" title="delete 指令"></a>delete 指令</h3><h4 id="删除表中符合条件的数据"><a href="#删除表中符合条件的数据" class="headerlink" title="删除表中符合条件的数据"></a>删除表中符合条件的数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> [database_name.]table_name [<span class="keyword">where</span> clause]</span><br></pre></td></tr></table></figure><blockquote><p>如果没有指定条件[where clause],那么表中所有的数据都会删除.</p></blockquote><h3 id="alter-指令"><a href="#alter-指令" class="headerlink" title="alter 指令"></a>alter 指令</h3><h4 id="修改列的类型"><a href="#修改列的类型" class="headerlink" title="修改列的类型"></a>修改列的类型</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [database.]table_name <span class="keyword">modify</span> column_name column_type;</span><br></pre></td></tr></table></figure><p>示例：修改字符串长度</p><p><img src="http://veng.gitee.io/hexo/2020/04/08/mysql/assets/1584093057251.png" alt="1584093057251"></p><h4 id="修改列名以及类型"><a href="#修改列名以及类型" class="headerlink" title="修改列名以及类型"></a>修改列名以及类型</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [database.]table_name <span class="keyword">change</span> column_name new_column_name column_type;</span><br></pre></td></tr></table></figure><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [database.]table_name <span class="keyword">rename</span> <span class="keyword">to</span> new_table_name;</span><br></pre></td></tr></table></figure><h4 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [database.]table_name <span class="keyword">add</span> column_name column_type;</span><br></pre></td></tr></table></figure><h4 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [database.]table_name <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br></pre></td></tr></table></figure><h4 id="添加主键"><a href="#添加主键" class="headerlink" title="添加主键"></a>添加主键</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [database.]table_name <span class="keyword">add</span> primary <span class="keyword">key</span>(column_name,...);</span><br></pre></td></tr></table></figure><h3 id="修改表结构-添加索引"><a href="#修改表结构-添加索引" class="headerlink" title="修改表结构(添加索引)"></a>修改表结构(添加索引)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [database.]table_name <span class="keyword">add</span> <span class="keyword">index</span> index_name(column_name,...);</span><br></pre></td></tr></table></figure><h3 id="desc-指令"><a href="#desc-指令" class="headerlink" title="desc 指令"></a>desc 指令</h3><h4 id="查看表的信息概况"><a href="#查看表的信息概况" class="headerlink" title="查看表的信息概况"></a>查看表的信息概况</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc [database.]table_name;</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="http://veng.gitee.io/hexo/2020/04/08/mysql/assets/1584092085053.png" alt="1584092085053"></p><h3 id="truncate-指令"><a href="#truncate-指令" class="headerlink" title="truncate 指令"></a>truncate 指令</h3><h4 id="清空某表"><a href="#清空某表" class="headerlink" title="清空某表"></a>清空某表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> [database.]table_name;</span><br></pre></td></tr></table></figure><h3 id="show-指令"><a href="#show-指令" class="headerlink" title="show 指令"></a>show 指令</h3><h4 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库."></a>查看所有数据库.</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure><h4 id="查看表的创建信息"><a href="#查看表的创建信息" class="headerlink" title="查看表的创建信息"></a>查看表的创建信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> [database.]table_name;</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="http://veng.gitee.io/hexo/2020/04/08/mysql/assets/1584091951728.png" alt="1584091951728"></p><p>会显示表的创建<code>sql</code>语句。</p><h4 id="显示索引信息"><a href="#显示索引信息" class="headerlink" title="显示索引信息"></a>显示索引信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> [database.]table_name;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;create-指令&quot;&gt;&lt;a href=&quot;#create-指令&quot; class=&quot;headerlink&quot; title=&quot;create 指令&quot;&gt;&lt;/a&gt;create 指令&lt;/h3&gt;&lt;h4 id=&quot;创建表&quot;&gt;&lt;a href=&quot;#创建表&quot; class=&quot;headerlink&quot; title=&quot;创建表&quot;&gt;&lt;/a&gt;创建表&lt;/h4&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; [database_name.]table_name (column_name column_type ,...,primary &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt;(column_name,...));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;select-指令&quot;&gt;&lt;a href=&quot;#select-指令&quot; class=&quot;headerlink&quot; title=&quot;select 指令&quot;&gt;&lt;/a&gt;select 指令&lt;/h3&gt;&lt;h4 id=&quot;查询某表指定列数据&quot;&gt;&lt;a href=&quot;#查询某表指定列数据&quot; class=&quot;headerlink&quot; title=&quot;查询某表指定列数据&quot;&gt;&lt;/a&gt;查询某表指定列数据&lt;/h4&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; column_name,...  &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; [database_name.]table_name;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="后台" scheme="http://veng.gitee.io/hexo/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="mysql" scheme="http://veng.gitee.io/hexo/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>各种镜像加速配置</title>
    <link href="http://veng.gitee.io/hexo/2020/04/03/%E5%90%84%E7%A7%8D%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/"/>
    <id>http://veng.gitee.io/hexo/2020/04/03/%E5%90%84%E7%A7%8D%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/</id>
    <published>2020-04-03T08:57:41.000Z</published>
    <updated>2020-12-09T01:01:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="各种镜像加速配置"><a href="#各种镜像加速配置" class="headerlink" title="各种镜像加速配置"></a>各种镜像加速配置</h2><h3 id="docker-镜像加速"><a href="#docker-镜像加速" class="headerlink" title="docker 镜像加速"></a>docker 镜像加速</h3><p>Linux下,<code>/etc/docker/daemon.json</code>,如果没有则创建.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"registry-mirrors"</span>:[</span><br><span class="line"><span class="string">"http://f1361db2.m.daocloud.io"</span>,</span><br><span class="line"><span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line"><span class="string">"https://hub-mirror.c.163.com"</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>然后重新加载配置,并重启docker.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><blockquote><p>注意: 配置文件的json格式要严格,最后的一项的逗号一定不要加,否则docker会启动失败.</p></blockquote><p>上面的地址可能失效,还可以使用阿里云镜像加速(个人推荐):</p><p>1.在阿里云平台上搜索 <code>容器镜像服务</code>.</p><p><img src="http://veng.gitee.io/hexo/2020/04/03/%E5%90%84%E7%A7%8D%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/assets/1587303273662.png" alt="1587303273662"></p><p><img src="http://veng.gitee.io/hexo/2020/04/03/%E5%90%84%E7%A7%8D%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/assets/1587303291915.png" alt="1587303291915"></p><p>2.开通此服务</p><p>3.获取加速器地址</p><p><img src="http://veng.gitee.io/hexo/2020/04/03/%E5%90%84%E7%A7%8D%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/assets/1587303350859.png" alt="1587303350859"></p><p>4.将此地址加入到daemon.json中.</p><h3 id="gradle-镜像加速"><a href="#gradle-镜像加速" class="headerlink" title="gradle 镜像加速"></a>gradle 镜像加速</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    ext.kotlin_version = <span class="string">'1.2.71'</span></span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">    <span class="comment">// 以下四行代码为阿里gradle 源</span></span><br><span class="line">        maven&#123; url <span class="string">'https://maven.aliyun.com/repository/google'</span>&#125;</span><br><span class="line">        maven&#123; url <span class="string">'https://maven.aliyun.com/repository/gradle-plugin'</span>&#125;</span><br><span class="line">        maven&#123; url <span class="string">'https://maven.aliyun.com/repository/public'</span>&#125;</span><br><span class="line">        maven&#123; url <span class="string">'https://maven.aliyun.com/repository/jcenter'</span>&#125;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:3.2.0'</span></span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">    <span class="comment">// 所有的model 都优先使用阿里源</span></span><br><span class="line">        maven&#123; url <span class="string">'https://maven.aliyun.com/repository/google'</span>&#125;</span><br><span class="line">        maven&#123; url <span class="string">'https://maven.aliyun.com/repository/gradle-plugin'</span>&#125;</span><br><span class="line">        maven&#123; url <span class="string">'https://maven.aliyun.com/repository/public'</span>&#125;</span><br><span class="line">        maven&#123; url <span class="string">'https://maven.aliyun.com/repository/jcenter'</span>&#125;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> clean(type: <span class="keyword">Delete</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="maven镜像加速"><a href="#maven镜像加速" class="headerlink" title="maven镜像加速"></a>maven镜像加速</h3><p>修改maven安装路径下,<code>/conf/setting.xml</code>,在<code>&lt;mirrors&gt;&lt;/mirrors&gt;</code>标签添加阿里云镜像.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="NVM镜像加速"><a href="#NVM镜像加速" class="headerlink" title="NVM镜像加速"></a>NVM镜像加速</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加 ~/.bashrc 末尾</span></span><br><span class="line">export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行生效</span></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="nodejs-镜像加速"><a href="#nodejs-镜像加速" class="headerlink" title="nodejs 镜像加速"></a>nodejs 镜像加速</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>配置完后,可以通过以下命令查看是否配置成功.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config ls</span><br></pre></td></tr></table></figure><h3 id="PIP-镜像加速"><a href="#PIP-镜像加速" class="headerlink" title="PIP 镜像加速"></a>PIP 镜像加速</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line">pip config set global.index-url https://pypi.douban.com/simple/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 其他镜像源</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://mirrors.aliyun.com/pypi/simple/      阿里云 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://pypi.tuna.tsinghua.edu.cn/simple/   清华大学 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://pypi.mirrors.ustc.edu.cn/simple/    中国科技大学</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://pypi.mirrors.ustc.edu.cn/simple/     中国科学技术大学</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;各种镜像加速配置&quot;&gt;&lt;a href=&quot;#各种镜像加速配置&quot; class=&quot;headerlink&quot; title=&quot;各种镜像加速配置&quot;&gt;&lt;/a&gt;各种镜像加速配置&lt;/h2&gt;&lt;h3 id=&quot;docker-镜像加速&quot;&gt;&lt;a href=&quot;#docker-镜像加速&quot; class=&quot;headerlink&quot; title=&quot;docker 镜像加速&quot;&gt;&lt;/a&gt;docker 镜像加速&lt;/h3&gt;&lt;p&gt;Linux下,&lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;,如果没有则创建.&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attr&quot;&gt;&quot;registry-mirrors&quot;&lt;/span&gt;:[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;http://f1361db2.m.daocloud.io&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;https://dockerhub.azk8s.cn&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;https://hub-mirror.c.163.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="其他" scheme="http://veng.gitee.io/hexo/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="镜像" scheme="http://veng.gitee.io/hexo/tags/%E9%95%9C%E5%83%8F/"/>
    
      <category term="加速" scheme="http://veng.gitee.io/hexo/tags/%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>react-router</title>
    <link href="http://veng.gitee.io/hexo/2020/04/03/react-router/"/>
    <id>http://veng.gitee.io/hexo/2020/04/03/react-router/</id>
    <published>2020-04-03T08:02:07.000Z</published>
    <updated>2020-12-08T05:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>react-router 是对你前端路由的管理配置.</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><font color="#ef0522">注意</font></h4><p>React项目的可用的路由库是<code>React-Router</code>,当然这也是官方支持的。它也分为：</p><ul><li><p>react-router 核心组件</p></li><li><p>react-router-dom 应用于浏览器端的路由库（单独使用包含了react-router的核心部分）</p></li><li><p>react-router-native 应用于native端的路由</p><a id="more"></a><p>我用的web端路由库:</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"react-router-dom"</span>: <span class="string">"^5.1.2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体看<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">官方网站 https://reacttraining.com/react-router/web/guides/quick-start</a>.</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-router-dom</span><br></pre></td></tr></table></figure><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>示例:比如一个页面有导航栏跟内容.</p><p><code>index-router.js</code>: 主页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Router, Switch, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'./About'</span>;</span><br><span class="line"><span class="keyword">import</span> Inbox <span class="keyword">from</span> <span class="string">'./Inbox'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexRouter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &lt;h1&gt;app&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;nav&gt;</span></span><br><span class="line"><span class="regexp">          &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;&lt;Link to='about'&gt;to About&lt;/</span>Link&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;&lt;Link to='inbox'&gt;to Inbox&lt;/</span>Link&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/u</span>l&gt;</span><br><span class="line">        &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Route path='/</span>about<span class="string">' component=&#123;About&#125; /&gt;</span></span><br><span class="line"><span class="string">          &lt;Route path='</span>/inbox<span class="string">'&gt;</span></span><br><span class="line"><span class="string">            &lt;Inbox /&gt;</span></span><br><span class="line"><span class="string">          &lt;/Route&gt;</span></span><br><span class="line"><span class="string">        &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">      &lt;/Router&gt;</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ReactDOM.render(&lt;IndexRouter/&gt;, document.getElementById('</span>root<span class="string">'));</span></span><br></pre></td></tr></table></figure><p>现在我们主页有一个导航栏,Link标签是来自<code>react-router-dom</code>.</p><p>这样形成的效果为:</p><p><img src="http://veng.gitee.io/hexo/2020/04/03/react-router/assets/react-router-0.gif" alt="react-router-0"></p><p>这里用到了 Link, Switch, Router,Route.</p><h3 id="react-router-dom组件"><a href="#react-router-dom组件" class="headerlink" title="react-router-dom组件"></a>react-router-dom组件</h3><h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p>替代了<code>&lt;a/&gt;</code>标签,而且比其更多的扩展.</p><p>属性<code>to</code>来指向要跳转的地方,可以是字符串,可以是对象,可以是一个function.</p><p>当是字符串的时,字符串要指向跳转的地址location,第一个斜杠加不加结果都一样.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">'about'</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- or --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">'/about'</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当是对象的时候,与字符串的时候有了更多的扩展,对象结构有:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    pathname: '表示链接的地址,跟字符串时一样',</span><br><span class="line">    search: '表示地址query的参数,如 ?sort=name',</span><br><span class="line">    hash: '表示地址的hash,如 #about',</span><br><span class="line">    state: '保存状态到该地址 官方:State to persist to the location',</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Switch, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'./About'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> location = &#123;</span><br><span class="line">    pathname: <span class="string">'about'</span>,</span><br><span class="line">    search: <span class="string">'?to=about'</span>,</span><br><span class="line">    hash: <span class="string">'#a'</span>,</span><br><span class="line">    state: &#123;</span><br><span class="line">      test: <span class="string">'value'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;nav&gt;</span><br><span class="line">        &lt;Link to=&#123;location&#125; &gt;to about&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>nav&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=<span class="string">'/about'</span> component=&#123;About&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="http://veng.gitee.io/hexo/2020/04/03/react-router/assets/react-router-1.gif" alt="react-router-1"></p><p>对于<code>state</code>,关于官方的解释我也是一知半解,总之它会把该数值传给<code>About</code>组件,在<code>props</code>的<code>location</code>中存着:</p><p><img src="http://veng.gitee.io/hexo/2020/04/03/react-router/assets/1584986174433.png" alt="1584986174433"></p><p>从图可知,to中的对象都在location里存着.</p><h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p>The common low-level interface for all router components. Typically apps will use one of the high-level routers instead.</p><p>就是说Router只是一个所有router组件的公共接口,要使用则用它的实现类组件:</p><ul><li><code>&lt;BrowserRouter&gt;</code></li><li><code>&lt;HashRouter&gt;</code></li><li><code>&lt;MemoryRouter&gt;</code></li><li><code>&lt;NativeRouter&gt;</code></li><li><code>&lt;StaticRouter&gt;</code></li></ul><p>这里我们只讲前两种.</p><h5 id="BrowseRouter"><a href="#BrowseRouter" class="headerlink" title="BrowseRouter"></a>BrowseRouter</h5><p>就是我们常见的url,history模式.</p><p>你可能也注意到了我们之前用得都是这个 Router,它得路径就是斜杠加路径完事.</p><p>但是它也有几个参数,</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    basename: '根路径',</span><br><span class="line">    forceRefresh: '是否刷新',</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'./About'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;BrowserRouter basename=<span class="string">'/browser'</span>&gt;</span><br><span class="line">      &lt;nav&gt;</span><br><span class="line">        &lt;Link to=<span class="string">'/about'</span>&gt;to about&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>nav&gt;</span><br><span class="line">      &lt;Route path=<span class="string">'/about'</span> component=&#123;About&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>此时设置的根路径是:/browser,</p><p><img src="http://veng.gitee.io/hexo/2020/04/03/react-router/assets/react-router-3-1585059032007.gif" alt="react-router-3"></p><h5 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h5><p>这种Router模式是hash模式.不像之前直接后面跟斜杠路径,而是hash值.</p><p>配置项:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    basename: '根路径',</span><br><span class="line">    hashType: '有三种选择:slash(default),noslash,hashbang'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例: 默认 hashType</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Link, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'./About'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;HashRouter basename=<span class="string">'/root'</span>&gt;</span><br><span class="line">      &lt;nav&gt;</span><br><span class="line">        &lt;Link to=<span class="string">'/about'</span>&gt;to about&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>nav&gt;</span><br><span class="line">      &lt;Route exact path=<span class="string">'/about'</span> component=&#123;About&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>默认 hashType模式 slash.</p><p><img src="http://veng.gitee.io/hexo/2020/04/03/react-router/assets/react-router-hash-root.gif" alt="react-router-hash-root"></p><p>示例: noslash</p><p><img src="http://veng.gitee.io/hexo/2020/04/03/react-router/assets/react-router-hash-root-2.gif" alt="react-router-hash-root-2"></p><p>两种类型区别就在于多了一个斜杠.</p><h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><p>The Route component is perhaps the most important component in React Router to understand and learn to use well. Its most basic responsibility is to render some UI when its <code>path</code> matches the current URL.</p><p>必须与Router一起使用,然后会在Router里去匹配地址,找到Route.</p><p>从之前例子中我们可以看出来,Route相当于二级路径.</p><h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5><p>对于Route的props有:</p><ul><li>match</li><li>location</li><li>history</li></ul><p>首先match是有关路径上的参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./User'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;Route path=<span class="string">'/user/:username'</span> component=&#123;User&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h2&gt;hello &#123;props.match.params.username&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="http://veng.gitee.io/hexo/2020/04/03/react-router/assets/1585065479312.png" alt="1585065479312"></p><p>其他信息:</p><p><img src="http://veng.gitee.io/hexo/2020/04/03/react-router/assets/1585065659370.png" alt="1585065659370"></p><p>至于history,就是提供了历史前进后退得函数.</p><p><img src="http://veng.gitee.io/hexo/2020/04/03/react-router/assets/1585065716751.png" alt="1585065716751"></p><ul><li><code>push(path, [state])</code> - 跳转到指定路径</li><li><code>replace(path, [state])</code> - 直接替换路径</li><li><code>go(n)</code> - 历史前进几步</li><li><code>goBack()</code> - 历史后退几步</li><li><code>goForward()</code> - 相当于 go(1).</li></ul><h5 id="exact属性"><a href="#exact属性" class="headerlink" title="exact属性"></a>exact属性</h5><p>路径匹配的严格程度.</p><table><thead><tr><th align="center">path</th><th align="center">location.pathname</th><th align="center">exact</th><th align="center">matches?</th></tr></thead><tbody><tr><td align="center"><code>/one</code></td><td align="center"><code>/one/two</code></td><td align="center"><code>true</code></td><td align="center">no</td></tr><tr><td align="center"><code>/one</code></td><td align="center"><code>/one/two</code></td><td align="center"><code>false</code></td><td align="center">yes</td></tr></tbody></table><h5 id="sensitive属性"><a href="#sensitive属性" class="headerlink" title="sensitive属性"></a><strong>sensitive属性</strong></h5><p>表示是否大小写敏感.</p><h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h4><p>Renders the first child <code>&lt;Route&gt;</code> or <code>&lt;Redirect&gt;</code>that matches the location.</p><p>就是说如果有多个路由匹配一样,那么只会渲染第一个<code>route</code>.</p><p>示例:</p><p><strong>不用switch</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, BrowserRouter <span class="keyword">as</span> Router &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'./About'</span>;</span><br><span class="line"><span class="keyword">import</span> Inbox <span class="keyword">from</span> <span class="string">'./Inbox'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">        &lt;Route path=<span class="string">'/about'</span> component=&#123;About&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">'/about'</span> component=&#123;Inbox&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这里同一个地址,我们有两个组件,我们没有用 <code>Switch</code>结果会是这样,两个都显示:</p><p><img src="http://veng.gitee.io/hexo/2020/04/03/react-router/assets/1584987506035.png" alt="1584987506035"></p><p><strong>使用 switch:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, BrowserRouter <span class="keyword">as</span> Router, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'./About'</span>;</span><br><span class="line"><span class="keyword">import</span> Inbox <span class="keyword">from</span> <span class="string">'./Inbox'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=<span class="string">'/about'</span> component=&#123;About&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">'/about'</span> component=&#123;Inbox&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果会是这样,只会渲染第一个:</p><p><img src="http://veng.gitee.io/hexo/2020/04/03/react-router/assets/1584988002294.png" alt="1584988002294"></p><h3 id="Hook-钩子"><a href="#Hook-钩子" class="headerlink" title="Hook 钩子"></a>Hook 钩子</h3><p>react-router-dom 中提供了一些方法.</p><ul><li>useHistory</li><li>useLocation</li><li>useParams</li><li>useRouteMatch</li></ul><p>这些可以获取其对象,其实也可以通过props获取到.</p><p>示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useHistory &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">const</span> history = useHistory();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;react-router&quot;&gt;&lt;a href=&quot;#react-router&quot; class=&quot;headerlink&quot; title=&quot;react-router&quot;&gt;&lt;/a&gt;react-router&lt;/h2&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;react-router 是对你前端路由的管理配置.&lt;/p&gt;
&lt;h4 id=&quot;注意&quot;&gt;&lt;a href=&quot;#注意&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#ef0522&quot;&gt;注意&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;React项目的可用的路由库是&lt;code&gt;React-Router&lt;/code&gt;,当然这也是官方支持的。它也分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;react-router 核心组件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;react-router-dom 应用于浏览器端的路由库（单独使用包含了react-router的核心部分）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;react-router-native 应用于native端的路由&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://veng.gitee.io/hexo/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react" scheme="http://veng.gitee.io/hexo/tags/react/"/>
    
      <category term="react-router" scheme="http://veng.gitee.io/hexo/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose安装</title>
    <link href="http://veng.gitee.io/hexo/2020/04/02/docker-compose%E5%AE%89%E8%A3%85/"/>
    <id>http://veng.gitee.io/hexo/2020/04/02/docker-compose%E5%AE%89%E8%A3%85/</id>
    <published>2020-04-02T11:07:50.000Z</published>
    <updated>2020-12-08T05:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>由于官方下载速度非常慢,所以切换到了国内镜像:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><a id="more"></a><p>然后再赋予执行权限:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>检查安装是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><p><img src="http://veng.gitee.io/hexo/2020/04/02/docker-compose%E5%AE%89%E8%A3%85/assets/1585825593637.png" alt="1585825593637"></p><h3 id="可能碰到的问题"><a href="#可能碰到的问题" class="headerlink" title="可能碰到的问题"></a>可能碰到的问题</h3><ol><li>下载时,权限不足: 切换到 <code>root</code>用户下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><ol start="2"><li>切换到<code>root</code>用户时,出现<code>su</code>鉴定故障</li></ol><p>这是因为在安装<code>linux</code>系统时没有给root用户设置密码，重新设置密码即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker-compose安装&quot;&gt;&lt;a href=&quot;#docker-compose安装&quot; class=&quot;headerlink&quot; title=&quot;docker-compose安装&quot;&gt;&lt;/a&gt;docker-compose安装&lt;/h2&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;由于官方下载速度非常慢,所以切换到了国内镜像:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-compose&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="后台" scheme="http://veng.gitee.io/hexo/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="docker" scheme="http://veng.gitee.io/hexo/tags/docker/"/>
    
      <category term="docker-compose" scheme="http://veng.gitee.io/hexo/tags/docker-compose/"/>
    
  </entry>
  
  <entry>
    <title>nodejs发送邮件</title>
    <link href="http://veng.gitee.io/hexo/2020/03/19/nodejs%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <id>http://veng.gitee.io/hexo/2020/03/19/nodejs%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</id>
    <published>2020-03-18T19:13:15.000Z</published>
    <updated>2020-12-08T05:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nodejs发送邮件"><a href="#nodejs发送邮件" class="headerlink" title="nodejs发送邮件"></a><code>nodejs</code>发送邮件</h2><ol><li>安装 <code>nodemailer</code>库.</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i nodemailer</span><br></pre></td></tr></table></figure><a id="more"></a><ol start="2"><li>配置发送方的服务器，账号和密码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">'nodemailer'</span>);</span><br><span class="line"><span class="keyword">const</span> transporter = nodemailer.createTransport(&#123;</span><br><span class="line">  host: <span class="string">'smtp.qq.com'</span>,</span><br><span class="line">  port: <span class="number">587</span>,</span><br><span class="line">  secure: <span class="literal">false</span>, <span class="comment">// true for 465, false for other ports</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    user: <span class="string">'xxxxx@qq.com'</span>,</span><br><span class="line">    pass: <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>发送邮件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 发送指定主题以及内容给指定邮箱</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>to 接收者的邮箱</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>subject 邮件主题</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>body 邮件内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">async</span> sendEmail(to, subject, body) &#123;</span><br><span class="line">   <span class="keyword">await</span> transporter.sendMail(&#123;</span><br><span class="line">     <span class="keyword">from</span>: admin_email,</span><br><span class="line">     to, subject,</span><br><span class="line">     text: body,</span><br><span class="line">     <span class="comment">// html: '',</span></span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>发送简单邮件。</p><p><strong>备注：</strong></p><p>我发送方的邮箱用的是 QQ邮箱，其中密码并不是QQ密码而是授权码，通过QQ邮箱里获得。</p><p>在邮箱设置，账户下：</p><p><img src="http://veng.gitee.io/hexo/2020/03/19/nodejs%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/assets/1584014965065.png" alt="1584014965065"></p><p><img src="http://veng.gitee.io/hexo/2020/03/19/nodejs%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/assets/1584014989755.png" alt="1584014989755"></p><p>然后把 SMTP 服务打开，我们用的该服务，然后点击生成授权码生成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;nodejs发送邮件&quot;&gt;&lt;a href=&quot;#nodejs发送邮件&quot; class=&quot;headerlink&quot; title=&quot;nodejs发送邮件&quot;&gt;&lt;/a&gt;&lt;code&gt;nodejs&lt;/code&gt;发送邮件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装 &lt;code&gt;nodemailer&lt;/code&gt;库.&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm i nodemailer&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="后台" scheme="http://veng.gitee.io/hexo/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="nodejs" scheme="http://veng.gitee.io/hexo/tags/nodejs/"/>
    
      <category term="nodemailer" scheme="http://veng.gitee.io/hexo/tags/nodemailer/"/>
    
      <category term="邮件" scheme="http://veng.gitee.io/hexo/tags/%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>hexo 搭建个人博客</title>
    <link href="http://veng.gitee.io/hexo/2020/03/19/hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://veng.gitee.io/hexo/2020/03/19/hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-03-18T18:25:15.000Z</published>
    <updated>2020-12-08T05:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo-搭建个人博客"><a href="#hexo-搭建个人博客" class="headerlink" title="hexo 搭建个人博客"></a>hexo 搭建个人博客</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>是快速、简洁且高效的博客框架.我之前都是使用了<code>gitbook+git+typora+github</code>,现在使用了一段<code>hexo</code>,发现也不错,与之前的相比界面主题上显得比<code>hexo</code>要好看的多.</p><a id="more"></a><p>两者对比:</p><p><code>gitbook</code>:</p><p><img src="http://veng.gitee.io/hexo/2020/03/19/hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/assets/1584554452185.png" alt="1584554452185"></p><p><code>hexo</code>:</p><p><img src="http://veng.gitee.io/hexo/2020/03/19/hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/assets/1584554517306.png" alt="1584554517306"></p><h4 id="安装-hexo-cli"><a href="#安装-hexo-cli" class="headerlink" title="安装 hexo-cli"></a>安装 <code>hexo-cli</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h4 id="初始化站点"><a href="#初始化站点" class="headerlink" title="初始化站点"></a>初始化站点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>这样就完成了博客的站点的初始化.</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>最关键就是<code>themes</code>和<code>_config.yml</code>这两个东西.</p><p><code>themes</code>文件夹下存放着主题,而<code>_config.yml</code>里是网站的 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a> 信息，您可以在此配置大部分的参数。主题的话可以去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo 主题</a>里找寻自己喜欢的主题,我选的是<a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">alpha-dust</a>.</p><p>然后将自己喜欢的主题下载到<code>themes</code>目录下.</p><p><img src="http://veng.gitee.io/hexo/2020/03/19/hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/assets/1584554680178.png" alt="1584554680178"></p><p>然后才能应用主题,<code>_config.yml</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Extensions</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Plugins: https://hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Themes: https://hexo.io/themes/</span></span></span><br><span class="line">theme: alpha-dust</span><br></pre></td></tr></table></figure><p>找到<code>theme</code>项将其改为你的主题名字,其他配置项<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">官方</a>都说明,这里不再说明.</p><h3 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a><code>hexo</code>命令</h3><h4 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p><code>laytou</code>默认是<code>post</code>,这里也可以在<code>_config.yml</code>找到<code>default_layout</code>配置项来进行配置,post是要发布的文章,layout还可以是<code>draft</code>,就是新建一片草稿. <code>title</code>是文章的题目.</p><p>新建完之后,会自动在<code>source</code>目录下先新建文章,这里用<code>markdown</code>来写文章的.</p><h4 id="发表草稿"><a href="#发表草稿" class="headerlink" title="发表草稿"></a>发表草稿</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>该命令会将草稿移动到<code>_posts</code>目录下.</p><h4 id="生成静态文件-html"><a href="#生成静态文件-html" class="headerlink" title="生成静态文件 html"></a>生成静态文件 html</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>会在<code>public</code>目录下生成.</p><h4 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>启动后你预览博客得样子.默认地址是<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>.</p><h4 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h4 id="清楚指令"><a href="#清楚指令" class="headerlink" title="清楚指令"></a>清楚指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><h3 id="部署到码云gitee"><a href="#部署到码云gitee" class="headerlink" title="部署到码云gitee"></a>部署到码云<code>gitee</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S hexo-deployer-git</span><br></pre></td></tr></table></figure><p>然后再配置文件里配置,<code>_config.yml</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">gitee:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">git-url</span></span><br><span class="line">      <span class="attr">branch:</span> <span class="string">分支名</span></span><br></pre></td></tr></table></figure><p>你也可以选择部署到<code>github</code>,但是<code>github</code>上只能部署到g<code>h-pages</code>或者<code>master</code>分支上.详细配置请看<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">https://github.com/hexojs/hexo-deployer-git</a>.</p><p>配置完后:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>然后你部署的仓库找到<code>gitee</code>服务配置<code>gitee pages</code>:</p><p><img src="http://veng.gitee.io/hexo/2020/03/19/hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/assets/1584556338529.png" alt="1584556338529"></p><p>然后你可以选择你要部署的分支:</p><p><img src="http://veng.gitee.io/hexo/2020/03/19/hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/assets/1584556545704.png" alt="1584556545704"></p><p>这样就完成了.</p><h3 id="图片显示问题"><a href="#图片显示问题" class="headerlink" title="图片显示问题"></a>图片显示问题</h3><p>成功之后会出现图片显示不正确,发现图片的路径更不对.故要修改图片路径.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/Veng0923/hexo-asset-image.git</span><br></pre></td></tr></table></figure><p>这个是要部署到<code>github</code>或者<code>gitee</code>上才会生效,我用的并不是相对地址.</p><p><a href="http://veng.gitee.io/hexo">我的个人博客地址</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hexo-搭建个人博客&quot;&gt;&lt;a href=&quot;#hexo-搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;hexo 搭建个人博客&quot;&gt;&lt;/a&gt;hexo 搭建个人博客&lt;/h2&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo&lt;/a&gt;是快速、简洁且高效的博客框架.我之前都是使用了&lt;code&gt;gitbook+git+typora+github&lt;/code&gt;,现在使用了一段&lt;code&gt;hexo&lt;/code&gt;,发现也不错,与之前的相比界面主题上显得比&lt;code&gt;hexo&lt;/code&gt;要好看的多.&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="http://veng.gitee.io/hexo/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="hexo" scheme="http://veng.gitee.io/hexo/tags/hexo/"/>
    
      <category term="搭建博客" scheme="http://veng.gitee.io/hexo/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>react进阶-redux</title>
    <link href="http://veng.gitee.io/hexo/2020/03/18/react%E8%BF%9B%E9%98%B6-redux/"/>
    <id>http://veng.gitee.io/hexo/2020/03/18/react%E8%BF%9B%E9%98%B6-redux/</id>
    <published>2020-03-18T15:42:40.000Z</published>
    <updated>2020-12-08T05:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react进阶-redux"><a href="#react进阶-redux" class="headerlink" title="react进阶-redux"></a>react进阶-redux</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p><code>Redux</code>，一种新型的前端“架构模式”。经常和 <code>React.js</code> 一并提出，你要用 <code>React.js</code> 基本都要伴随着 <code>Redux</code> 和 <code>React.js</code> 结合的库 <code>React-redux</code>。</p><blockquote><p>要注意的是，<code>Redux</code>和 <code>React-redux</code> 并不是同一个东西。<code>Redux</code>是一种架构模式（Flux 架构的一种变种），它不关注你到底用什么库，你可以把它应用到 <code>React</code>和 <code>Vue</code>，甚至跟 <code>jQuery</code>结合都没有问题。而 <code>React-redux</code> 就是把 <code>Redux</code>这种架构模式和 <code>React.js</code> 结合起来的一个库，就是 <code>Redux</code>架构在 <code>React.js</code> 中的体现。</p></blockquote><a id="more"></a><h4 id="安装redux和-react-redux"><a href="#安装redux和-react-redux" class="headerlink" title="安装redux和 react-redux"></a>安装<code>redux</code>和 <code>react-redux</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S redux react-redux</span><br></pre></td></tr></table></figure><p>那么如何去使用它们? 首先得了解<code>provider</code>组件,和<code>connect</code>以及<code>store</code>,<code>action</code>,<code>reducer</code>.</p><h3 id="解析-redux"><a href="#解析-redux" class="headerlink" title="解析 redux"></a>解析 <code>redux</code></h3><p><code>redux</code>中含有<code>store</code>,<code>action</code>,<code>reducer</code>.<code>redux</code>的作用是什么? 它们是如何工作的.</p><p><code>redux</code>的作用就是用来管理数据状态的.</p><blockquote><p>随着 JavaScript 单页应用开发日趋复杂，<strong>JavaScript 需要管理比任何时候都要多的 state （状态）</strong>。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。</p><p>管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。<strong>state 在什么时候，由于什么原因，如何变化已然不受控制。</strong> 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。</p></blockquote><p><code>store</code>,<code>action</code>,<code>reducer</code>是如何协调工作的?</p><p>假设我们有一个事情清单要维护:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  todos: [</span><br><span class="line">    &#123;</span><br><span class="line">      text: <span class="string">'eat food'</span>,</span><br><span class="line">      completed: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      text: <span class="string">'Exercise'</span>,</span><br><span class="line">      completed: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们如何去维护这些数据? 比如增加一个要做的事情.</p><p>而<code>reducer</code>就是做这个工作的,它完成了数据的初始化,并且决定了对这个数据有哪些行为.并且它还是一个纯函数(即不对参数进行修改的函数),要保证只要输入的参数一样,那么结果一定相同.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  todos: [],</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoReducer</span>(<span class="params">state=defaultState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'insert'</span>:</span><br><span class="line">      <span class="keyword">const</span> todo = &#123; <span class="attr">text</span>: action.text, <span class="attr">completed</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">todos</span>: [...state.todos, todo] &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只能够通过这个<code>todoReducer</code>来操作数据,以上我们需要传入行为<code>action</code>,定义操作的类型以及数据.显然这样通过字符串的形式来判断行为,是不行的.所以我们可以预先定义<code>action</code>,然后再传入,可以联想到设计模式中的工厂模式.</p><p><code>action.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> actionType = &#123;</span><br><span class="line">  insert: <span class="string">'insert'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> insertTodo = <span class="function">(<span class="params">value</span>)=&gt;</span>(&#123;</span><br><span class="line">  type: actionType.insert,</span><br><span class="line">  text: value,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>acitonType</code>规定了<code>aciton</code>的有那些行为,并且提供了一些<code>action</code>,这里我们演示只有一个增加的<code>action</code>.</p><p>然后我们<code>reducer</code>就能够写成:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; actionType &#125; <span class="keyword">from</span> <span class="string">'./action'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  todos: [],</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoReducer</span>(<span class="params">state = defaultState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> actionType.insert:</span><br><span class="line">      <span class="keyword">const</span> todo = &#123; <span class="attr">text</span>: action.text, <span class="attr">completed</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">todos</span>: [...state.todos, todo] &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todoReducer;</span><br></pre></td></tr></table></figure><p>这样子的话,我们可以通过获取<code>action</code>,给<code>reducer</code>来完成我们对数据的操作.</p><p>那么我们如何获取<code>state</code>数据? 如果有一个<code>getter</code>函数就好了,这就是<code>store</code>,并且它还封装了<code>reducer</code>.</p><p><code>store.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> todoReducer <span class="keyword">from</span> <span class="string">'./todoReducer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    state = reducer(state, action);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化state</span></span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state;</span><br><span class="line">  <span class="keyword">return</span> &#123; getState, dispatch &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(todoReducer);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p>这里的<code>store</code>有获取<code>state</code>的方法<code>getState</code>,还有对其操作的函数<code>dispatch</code>.故我们只要通过<code>store</code>就能够对数据进行操作.</p><p>示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; insertTodo &#125; <span class="keyword">from</span> <span class="string">'./action'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="built_in">console</span>.table(store.getState());</span><br><span class="line">    store.dispatch(insertTodo(<span class="string">'run'</span>));</span><br><span class="line">    store.dispatch(insertTodo(<span class="string">'write a blog'</span>));</span><br><span class="line">    <span class="built_in">console</span>.table(store.getState());</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123; </span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Test;</span><br></pre></td></tr></table></figure><p>这里我们增加了两个事件,验证一下:</p><p><img src="http://veng.gitee.io/hexo/2020/03/18/react%E8%BF%9B%E9%98%B6-redux/assets/1584540788426.png" alt="1584540788426"></p><p>这就是<code>redux</code>的工作原理,还有一个问题就是<code>store</code>就像是全局变量,可能两个组件的数据变量可能会重复,会出现不方便维护,解决方案是我们为每个组件设置成单独的数据域,就好像:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    app:&#123;...&#125;,</span><br><span class="line">    todoList: &#123;...&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似这种效果,这样也不会产生数据的污染.</p><p><code>redux</code>恰好就提供了<code>combineReducers</code>函数来实现这个效果.它就是结合<code>reducer</code>来为索引.</p><p>先创建一个总的 <code>reducer</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> todoReducer <span class="keyword">from</span> <span class="string">'./todoReducer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  todoReducer,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer;</span><br></pre></td></tr></table></figure><p>这里将刚才的<code>todoReducer</code>放进去总<code>reducer</code>.</p><p>然后我们的<code>store</code>引入该<code>reducer</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./rootReducer'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p><code>createStore</code>,是<code>redux</code>已经帮我们写好了,我们直接用就行.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="built_in">console</span>.table(store.getState());</span><br><span class="line">  store.dispatch(insertTodo(<span class="string">'run'</span>));</span><br><span class="line">  store.dispatch(insertTodo(<span class="string">'write a blog'</span>));</span><br><span class="line">  <span class="built_in">console</span>.table(store.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同样的对其进行打印,看看数据是否有变化.</p><p><img src="http://veng.gitee.io/hexo/2020/03/18/react%E8%BF%9B%E9%98%B6-redux/assets/1584542916546.png" alt="1584542916546"></p><p>我们可以看到,<code>store</code>保存的数据结构已经发生了变化,已经开始分区域保存数据,实际保存数据的其实是<code>reducer</code>,只不过<code>store</code>包含了所有的<code>reducer</code>.</p><h3 id="结合-react-redux"><a href="#结合-react-redux" class="headerlink" title="结合 react-redux"></a>结合 <code>react-redux</code></h3><p><code>React-Redux</code>是<code>Redux</code>的官方<code>React</code>绑定库。它能够使你的<code>React</code>组件从<code>Redux store</code>中读取数据，并且向<code>store</code>分发<code>actions</code>以更新数据.</p><p><code>react-redux</code>提供了两个东西,<code>&lt;Provider/&gt;</code>组件和<code>connect</code>函数.</p><blockquote><p><code>React-Redux</code> 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。</p><p>UI 组件:</p><p>只负责 UI 的呈现，不带有任何业务逻辑,没有状态（即不使用this.state这个变量,所有数据都由参数（this.props）提供,</p><p>不使用任何 Redux 的 API.</p><p>容器组件:</p><p>容器组件的特征恰恰相反,负责管理数据和业务逻辑，不负责 UI 的呈现,带有内部状态,使用 Redux 的 API</p></blockquote><h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h4><p><code>React-Redux</code> 提供<code>&lt;Provider/&gt;</code>组件，能够使你的整个<code>app</code>访问到<code>Redux store</code>中的数据.</p><p>源码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      store: <span class="keyword">this</span>.props.store</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其作用就是将<code>store</code>绑定在了上下文对象<code>context</code>,然后子组件就可以通过<code>context</code>获取到<code>store</code>.</p><h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p><code>connect</code>方法，用于从 <code>UI</code> 组件生成容器组件.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connect = <span class="function">(<span class="params">mapStateToProps</span>) =&gt;</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">      store: PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      <span class="keyword">let</span> stateProps = mapStateToProps(store.getState())</span><br><span class="line">      <span class="comment">// &#123;...stateProps&#125; 意思是把这个对象里面的属性全部通过 `props` 方式传递进去</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...stateProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Connect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它从<code>context</code>获取了<code>store</code>,并且将<code>store</code>里的数据,通过<code>props</code>注入到了组件,所以组件可以通过<code>props</code>里读取<code>store</code>里的数据,而<code>mapStateToProps</code>,顾名思义就是将<code>store</code>里的<code>state</code>映射到组件的<code>props</code>.</p><p>还能继续深入对<code>dispatch</code>进行映射,同样映射到<code>props</code>里,并且数据<code>dispatch</code>之后要重新渲染组件.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connect = <span class="function">(<span class="params">mapStateToProps, mapDispatchToProps</span>) =&gt;</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">      store: PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">      <span class="keyword">super</span>()</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        allProps: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillMount () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      <span class="keyword">this</span>._updateProps()</span><br><span class="line">      <span class="comment">// 订阅,只要dispatch就会调用传入的函数</span></span><br><span class="line">      store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>._updateProps())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _updateProps () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      <span class="keyword">let</span> stateProps = mapStateToProps</span><br><span class="line">        ? mapStateToProps(store.getState(), <span class="keyword">this</span>.props)</span><br><span class="line">        : &#123;&#125; <span class="comment">// 防止 mapStateToProps 没有传入</span></span><br><span class="line">      <span class="keyword">let</span> dispatchProps = mapDispatchToProps</span><br><span class="line">        ? mapDispatchToProps(store.dispatch, <span class="keyword">this</span>.props)</span><br><span class="line">        : &#123;&#125; <span class="comment">// 防止 mapDispatchToProps 没有传入</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        allProps: &#123;</span><br><span class="line">          ...stateProps,</span><br><span class="line">          ...dispatchProps,</span><br><span class="line">          ...this.props</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.state.allProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Connect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就也就完成了<code>state</code>和<code>dispatch</code>映射到<code>props</code>的过程.</p><p>实际上<code>react-redux</code>已经封装了该函数,所以我们直接用就行了.</p><p>示例: 将 <code>redux</code>和<code>react</code>结合起来,图像化.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'./components/react-redux/TodoList'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; insertTodo &#125; <span class="keyword">from</span> <span class="string">'./store/action'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">value</span>: <span class="string">''</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = e.target.value;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.insertTodo(<span class="keyword">this</span>.state.value);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      value:<span class="string">''</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;TodoList todos=&#123;this.props.todos&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const mapToStateToProps = (state) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    todos: state.todoReducer.todos,</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const mapToDispatchToProps = (dispatch) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    insertTodo: (value) =&gt; &#123; dispatch(insertTodo(value)) &#125;,</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default connect(mapToStateToProps, mapToDispatchToProps)(App);</span></span><br></pre></td></tr></table></figure><p>这里我们返回的是一个由<code>connect</code>生成的容器组件.并且完成了映射,将<code>state.todoReducer.todos</code>映射到了<code>props.todos</code>上,<code>dispatch</code>也是如此.所以在组件里,我们直接用<code>props</code>调用就行了,<code>TodoList</code>就是简单的<code>react</code>组件.</p><p>附上<code>TodoList.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Todo <span class="keyword">from</span> <span class="string">'./Todo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; todos &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Todo</span> <span class="attr">todo</span>=<span class="string">&#123;todo&#125;</span> /&gt;</span></span>;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default TodoList;</span></span><br></pre></td></tr></table></figure><p>以及<code>Todo.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; todo &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;todo.text&#125;</span><br><span class="line">        &#123;todo.completed ? <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'checkbox'</span> <span class="attr">checked</span> /&gt;</span></span></span><br><span class="line">          : <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'checkbox'</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Todo;</span></span><br></pre></td></tr></table></figure><blockquote><p>记住一定要<code>connect</code>生成的组件一定要在<code>&lt;Provider/&gt;</code>下才能有效,因为<code>connect</code>要通过<code>context</code>获取<code>store</code>,而<code>store</code>放在<code>context</code>的过程是有<code>&lt;Provider/&gt;</code>,前面已经讲过了.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/store'</span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><p>最后的效果:</p><p><img src="http://veng.gitee.io/hexo/2020/03/18/react%E8%BF%9B%E9%98%B6-redux/assets/sky10.3.gif" alt="sky10.3"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;react进阶-redux&quot;&gt;&lt;a href=&quot;#react进阶-redux&quot; class=&quot;headerlink&quot; title=&quot;react进阶-redux&quot;&gt;&lt;/a&gt;react进阶-redux&lt;/h2&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Redux&lt;/code&gt;，一种新型的前端“架构模式”。经常和 &lt;code&gt;React.js&lt;/code&gt; 一并提出，你要用 &lt;code&gt;React.js&lt;/code&gt; 基本都要伴随着 &lt;code&gt;Redux&lt;/code&gt; 和 &lt;code&gt;React.js&lt;/code&gt; 结合的库 &lt;code&gt;React-redux&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要注意的是，&lt;code&gt;Redux&lt;/code&gt;和 &lt;code&gt;React-redux&lt;/code&gt; 并不是同一个东西。&lt;code&gt;Redux&lt;/code&gt;是一种架构模式（Flux 架构的一种变种），它不关注你到底用什么库，你可以把它应用到 &lt;code&gt;React&lt;/code&gt;和 &lt;code&gt;Vue&lt;/code&gt;，甚至跟 &lt;code&gt;jQuery&lt;/code&gt;结合都没有问题。而 &lt;code&gt;React-redux&lt;/code&gt; 就是把 &lt;code&gt;Redux&lt;/code&gt;这种架构模式和 &lt;code&gt;React.js&lt;/code&gt; 结合起来的一个库，就是 &lt;code&gt;Redux&lt;/code&gt;架构在 &lt;code&gt;React.js&lt;/code&gt; 中的体现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://veng.gitee.io/hexo/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react" scheme="http://veng.gitee.io/hexo/tags/react/"/>
    
      <category term="redux" scheme="http://veng.gitee.io/hexo/tags/redux/"/>
    
      <category term="react-redux" scheme="http://veng.gitee.io/hexo/tags/react-redux/"/>
    
  </entry>
  
  <entry>
    <title>react</title>
    <link href="http://veng.gitee.io/hexo/2020/03/18/react/"/>
    <id>http://veng.gitee.io/hexo/2020/03/18/react/</id>
    <published>2020-03-18T05:04:32.000Z</published>
    <updated>2020-12-08T05:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-快速上手"><a href="#React-快速上手" class="headerlink" title="React 快速上手"></a>React 快速上手</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ol><li>开始一个<code>React</code>的项目.</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>Node &gt;= 8.10</code> 和 <code>npm &gt;= 5.6</code>,<code>npx</code>是 <a href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b" target="_blank" rel="noopener">npm 5.2+ 附带的 package 运行工具</a>。</p></blockquote><a id="more"></a><p>参数说明： </p><p><code>my-app</code>: 指的是项目路径，比如想在当前目录创建项目，则<code>npx create-react-app .</code> </p><p>过程可能会久一点,安装完之后,你会发现<code>git</code>已经是创建好的.<code>npm start</code>测试安装是否成功:</p><p><img src="http://veng.gitee.io/hexo/2020/03/18/react/assets/1584372361579.png" alt="1584372361579"></p><p>如果有以上信息,则成功,默认端口号是<code>3000</code>,按照提示我们访问,<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a>,一般会自动访问.</p><ol start="2"><li>从 <code>hello world</code>开始.</li></ol><p>程序主入口是<code>src/index.js</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#39;.&#x2F;index.css&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line">import * as serviceWorker from &#39;.&#x2F;serviceWorker&#39;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; If you want your app to work offline and load faster, you can change</span><br><span class="line">&#x2F;&#x2F; unregister() to register() below. Note this comes with some pitfalls.</span><br><span class="line">&#x2F;&#x2F; Learn more about service workers: https:&#x2F;&#x2F;bit.ly&#x2F;CRA-PWA</span><br><span class="line">serviceWorker.unregister();</span><br></pre></td></tr></table></figure><p>其中关键的是, <code>ReactDOM.render();</code>以上含义是将<code>APP</code>组件挂载到<code>root</code>上.那么这个<code>root</code>,又是哪里的.</p><p>到<code>public\index.html</code>文件下有:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>You need to enable JavaScript to run this app.<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>发现在该<code>html</code>文件下, <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>, 所以其实是让该组件挂载到该组件下.</p><p>所以我们可以修改挂载的内容.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;h2&gt;hello world&lt;&#x2F;h2&gt;, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure><p>再次运行应该就能看到 <code>hello world</code>, 访问<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a>.</p><h3 id="了解JSX"><a href="#了解JSX" class="headerlink" title="了解JSX"></a>了解<code>JSX</code></h3><p>它是一个 JavaScript 的语法扩展.它跟模板语言有点类似, 作用当然是让视图与数据进行分离, 从而使得组件进行复用.<code>JSX</code>可以生成 <code>React</code> “元素”.</p><p>示例: 对于刚才的 <code>hello world</code>,我们就可以利用.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const name &#x3D; &#39;Veng&#39;;</span><br><span class="line">const element &#x3D; &lt;h2&gt;hello ,&#123;name&#125;&lt;&#x2F;h2&gt;;</span><br><span class="line">ReactDOM.render(element, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure><p>这样就可以对视图和数据及进行分离, 可以动态的生成视图,变量用花括号<code>{}</code>括起来,并且这样模式是防注入攻击的, 就算是用户输入, 它会将输入内容转化为字符串解析.</p><p>实际上, 最好的做法是将组件单独成一个模块,然后再导入,跟之前原始的<code>&lt;App/&gt;</code> 一样.</p><blockquote><p><strong>注意</strong>:</p><p>要使用JSX,必须导入React才能够用.<code>import React from &#39;react&#39;;</code></p></blockquote><h3 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h3><p>什么是元素, 就像刚刚的 <code>const element = &lt;h2&gt;hello ,{name}&lt;/h2&gt;;</code>就是元素.与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。</p><blockquote><p><strong>注意：</strong></p><p>你可能会将元素与另一个被熟知的概念——“组件”混淆起来。组件是由元素构成的。</p></blockquote><h4 id="更新已渲染的元素"><a href="#更新已渲染的元素" class="headerlink" title="更新已渲染的元素."></a>更新已渲染的元素.</h4><p>React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。</p><p>根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 <code>ReactDOM.render()</code>。</p><p>示例: 时间显示器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function tick() &#123;</span><br><span class="line">  const element &#x3D; (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;it is &#123;new Date().toLocaleString()&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;);</span><br><span class="line">  ReactDOM.render(element, document.getElementById(&#39;root&#39;));</span><br><span class="line">&#125;</span><br><span class="line">setInterval(tick, 1000);</span><br></pre></td></tr></table></figure><p>这个例子会在 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener"><code>setInterval()</code></a> 回调函数，每秒都调用 <code>ReactDOM.render()</code>.</p><blockquote><p>在实践中，大多数 React 应用只会调用一次 <code>ReactDOM.render()</code>.</p></blockquote><p>上面的例子中, 虽然我们对整个页面进行更新,但是实际上<code>React</code>只进行了局部更新.<code>React DOM</code>会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 <code>DOM</code> 达到预期的状态。</p><p>为了验证渲染的部分,可以观察 <code>DOM</code>结构:</p><p><img src="http://veng.gitee.io/hexo/2020/03/18/react/assets/sky10.1.gif" alt="dom"></p><p>但是实际上, 我们需要的并不是<code>UI</code>随时间的变化而变化, 而是在在任意时刻给定状态. 由此就有了组件.</p><h3 id="组件-props"><a href="#组件-props" class="headerlink" title="组件 props"></a>组件 props</h3><p>组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。</p><h4 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h4><ol><li>开始定义第一个组件<code>src/components/Welcome.js</code>,有两种方式创建组件一种是通过函数,一种是通过<code>class</code>.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return (&lt;h2&gt;hello,&#123;props.name&#125;&lt;&#x2F;h2&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Welcome;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class Welcome extends React.Component&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;h2&gt;hello,&#123;this.props.name&#125;&lt;&#x2F;h2&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Welcome;</span><br></pre></td></tr></table></figure><p>每次组件更新时 <code>render</code> 方法都会被调用.</p><ol start="2"><li><code>src/index.js</code>,引入组件,并导入数据.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Welcome from &#39;.&#x2F;components&#x2F;Welcome&#39;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Welcome name&#x3D;&quot;Veng&quot;&#x2F;&gt;, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure><h4 id="复用组件"><a href="#复用组件" class="headerlink" title="复用组件"></a>复用组件</h4><p>从组件的构成可以看出,各自组件的数据是互不影响的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Welcome name&#x3D;&quot;A&quot; &#x2F;&gt;</span><br><span class="line">      &lt;Welcome name&#x3D;&quot;B&quot; &#x2F;&gt;</span><br><span class="line">      &lt;Welcome name&#x3D;&quot;C&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通常来说，每个新的 React 应用程序的顶层组件都是 <code>App</code> 组件。但是，如果你将 React 集成到现有的应用程序中，你可能需要使用像 <code>Button</code> 这样的小组件，并自下而上地将这类组件逐步应用到视图层的每一处。</p></blockquote><p>总得来说,就是组件的复用程度越高越好,这样也就更加的灵活.</p><blockquote><p>组件无论是使用<a href="https://react.docschina.org/docs/components-and-props.html#function-and-class-components" target="_blank" rel="noopener">函数声明还是通过 class 声明</a>，都决不能修改自身的 props</p></blockquote><p>那么为什么自身的<code>props</code>不能被修改? 因为如果出现这样情况,子组件的<code>props</code>是来自父组件,那么如果自组件的<code>props</code>值改变了,父组件也会改变.实际上,我们不能让这种情况发生.故而有了一个保存组件状态值的一个参数<code>state</code>,<code>props</code>仅仅用来初始化,<code>state</code>用来保存组件的状态,往子组件传递数据时用的是<code>state</code>,子组件用<code>props</code>接收,用自身得<code>state</code>保存状态,这样子递归,每个组件的状态<code>state</code>都是私有得.</p><h3 id="State-和-生命周期"><a href="#State-和-生命周期" class="headerlink" title="State 和 生命周期"></a>State 和 生命周期</h3><p>之前的时间显示,是每次都需要<code>Render</code>,我们希望,编写一次代码,便可以让时间组件自我更新:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们需要在 <code>Clock</code> 组件中添加 “state” 来实现这个功能。</p><p>State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。</p><ol><li>先将时间信息放在<code>state</code>里.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123; date: new Date() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;it is &#123;this.state.date.toLocaleString()&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Clock;</span><br></pre></td></tr></table></figure><p><code>constructor</code>是构造器,初始化状态.</p><p>这样子写了之后,时间并没自动更新,所以怎么让<code>state.date</code>更新? 同样得,我们可以设置一个计时器来进行对其更新.</p><p>那么计时器在哪里设置. 组件提供了第一次渲染时的函数<code>componentDidMount</code>,在<code>React</code>称之为<code>挂载 mount</code>,还有组件被删除时的函数<code>componentWillUnmount</code>,在<code>React</code>称之为<code>卸载 unmount</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123; date: new Date() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.timerId &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        date: new Date()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(this.timerId);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;it is &#123;this.state.date.toLocaleString()&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Clock;</span><br></pre></td></tr></table></figure><p>快速概括一下发生了什么和这些方法的调用顺序：</p><blockquote><ol><li>当 <code>&lt;Clock /&gt;</code> 被传给 <code>ReactDOM.render()</code>的时候，React 会调用 <code>Clock</code> 组件的构造函数。因为 <code>Clock</code> 需要显示当前的时间，所以它会用一个包含当前时间的对象来初始化 <code>this.state</code>。我们会在之后更新 state。</li><li>之后 React 会调用组件的 <code>render()</code> 方法。这就是 React 确定该在页面上展示什么的方式。然后 React 更新 DOM 来匹配 <code>Clock</code> 渲染的输出。</li><li>当 <code>Clock</code> 的输出被插入到 DOM 中后，React 就会调用 <code>ComponentDidMount()</code> 生命周期方法。在这个方法中，<code>Clock</code> 组件向浏览器请求设置一个计时器来每秒调用<code>setState()</code>。</li><li><code>Clock</code> 组件会通过调用 <code>setState()</code> 来计划进行一次 UI 更新。得益于 <code>setState()</code> 的调用，React 能够知道 state 已经改变了，然后会重新调用 <code>render()</code> 方法来确定页面上该显示什么。这一次，<code>render()</code> 方法中的 <code>this.state.date</code> 就不一样了，如此以来就会渲染输出更新过的时间。React 也会相应的更新 DOM。</li><li>一旦 <code>Clock</code> 组件从 DOM 中被移除，React 就会调用 <code>componentWillUnmount()</code> 生命周期方法，这样计时器就停止了</li></ol></blockquote><p>关于 <code>setState()</code>:</p><p>为什么不直接修改:<code>this.state.date=new Date()</code>? 代码没问题,但是这样子修改并不会通知组件,<code>state</code> 变了,所以构造函数是唯一可以给<code>this.state</code>赋值的地方.</p><blockquote><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用。</p><p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p></blockquote><p>例如，此代码可能会无法更新计数器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Wrong</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可能当前组件的通知排在前面,而后面又改变了,但是排在了后面.</p><p>要解决这个问题,可以让<code>setState()</code>接收一个函数而不是一个对象,这样渲染得时候保存是一个函数,就会回调.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Correct</span><br><span class="line">this.setState((state, props) &#x3D;&gt; (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>state 的存在,数据是自上往下流动的.</p><blockquote><p>这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数,顺序记住.</p></blockquote><blockquote><p>总结:</p><p><code>state</code> 的主要作用是用于组件保存、控制、修改<em>自己</em>的可变状态。<code>state</code> 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 <code>state</code> 是一个局部的、只能被组件自身控制的数据源。<code>state</code> 中状态可以通过 <code>this.setState</code> 方法进行更新，<code>setState</code> 会导致组件的重新渲染。</p><p><code>props</code> 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 <code>props</code>，否则组件的 <code>props</code> 永远保持不变。</p></blockquote><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同:</p><ul><li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li><li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li></ul><p>示例:</p><p>传统dom</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"activateLasers()"</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>react:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick&#x3D;&#123;activateLasers&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code>.</p></blockquote><p>示例:</p><p>传统的 HTML 中阻止链接默认打开一个新页面，你可以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span></span><br><span class="line">  Click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React 中，可能是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function ActionLink() &#123;</span><br><span class="line">function handleClick(e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(&#39;The link was clicked.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;a href&#x3D;&quot;#&quot; onClick&#x3D;&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;&#x2F;a&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样<code>a</code>标签的默认点击事件不会触发,页面不会跳转,这就是<code>preventDefault</code>的作用.</p><p>在这里，<code>e</code> 是一个合成事件。React 根据 <a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C 规范</a>来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。</p><p>使用 React 时，你一般不需要使用 <code>addEventListener</code> 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。</p><p>当你使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a> 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class Toggle extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123; isToggle: true &#125;;</span><br><span class="line"></span><br><span class="line">    this.handleToggleClick &#x3D; this.handleToggleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggleClick() &#123;</span><br><span class="line">    this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">      isToggle: !state.isToggle,</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;this.state.isToggle ? &#39;ON&#39; : &#39;OFF&#39;&#125;</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Toggle;</span><br></pre></td></tr></table></figure><p>其中的处理点击事件的方法,我们在初始化的时候给其绑定了this<code>this.handleToggleClick = this.handleToggleClick.bind(this);</code>,使得函数里的<code>this</code>指向组件,否则函数里的<code>this</code>是```undefined<code>,你必须谨慎对待 JSX 回调函数中的</code>this<code>,在 JavaScript 中，class 的方法默认不会绑定</code>this`。</p><p>如果你觉得<code>bind</code>这样麻烦,我们可以利用箭头函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleToggleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">    isToggle: !state.isToggle,</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不用<code>bind</code>了,这里的<code>this</code>会指向组件.</p><p>亦或者:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;e&#x3D;&gt;this.handleToggleClick(e)&#125;&gt;</span><br><span class="line">        &#123;this.state.isToggle ? &#39;ON&#39; : &#39;OFF&#39;&#125;</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样也是可行的,不过以上推荐第二种.</p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>在 React 中，你可以创建不同的组件来封装各种你需要的行为。然后，依据应用的不同状态，你可以只渲染对应状态下的部分内容。</p><p>示例:</p><p><code>src\components\Greeting.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function GuestGreeting() &#123;</span><br><span class="line">  return &lt;h1&gt;Please sign in!&lt;&#x2F;h1&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function UserGreeting() &#123;</span><br><span class="line">  return &lt;h1&gt;Welcome back!&lt;&#x2F;h1&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Greeting(props) &#123;</span><br><span class="line">  const &#123; isLogin &#125; &#x3D; props;</span><br><span class="line">  return isLogin ? &lt;UserGreeting &#x2F;&gt; : &lt;GuestGreeting &#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Greeting;</span><br></pre></td></tr></table></figure><p><code>src\index.js</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Greeting from &#39;.&#x2F;components&#x2F;Greeting&#39;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Greeting isLogin&#x3D;&#123;false&#125; &#x2F;&gt;, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure><p>这里组件会根据登录状况来返回不同的问候语.</p><p>复杂一点条件: 添加登录登出按钮.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import Greeting from &#39;.&#x2F;Greeting&#39;;</span><br><span class="line"></span><br><span class="line">class GreetingWithButton extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123; isLogin: props.isLogin &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleLoginClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      isLogin: true,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  handleLogoutClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      isLogin: false,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; isLogin &#125; &#x3D; this.state;</span><br><span class="line">    const button &#x3D; isLogin ? &lt;button onClick&#x3D;&#123;this.handleLogoutClick&#125;&gt;Logout&lt;&#x2F;button&gt;</span><br><span class="line">      : &lt;button onClick&#x3D;&#123;this.handleLoginClick&#125;&gt;Login&lt;&#x2F;button&gt;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Greeting isLogin&#x3D;&#123;this.state.isLogin&#125; &#x2F;&gt;</span><br><span class="line">        &#123;button&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default GreetingWithButton;</span><br></pre></td></tr></table></figure><h4 id="阻止渲染"><a href="#阻止渲染" class="headerlink" title="阻止渲染"></a>阻止渲染</h4><p>在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 <code>render</code> 方法直接返回 <code>null</code>，而不进行任何渲染。</p><p>示例:显示隐藏警告!</p><p><code>src\components\Warning.js</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class Warning extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; warn &#125; &#x3D; this.props;</span><br><span class="line">    return warn ? (</span><br><span class="line">      &lt;div className&#x3D;&#39;warning&#39;&gt;</span><br><span class="line">        Warning!</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    ) : null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Warning;</span><br></pre></td></tr></table></figure><p><code>src\components\Page.js</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import Warning from &#39;.&#x2F;Warning&#39;;</span><br><span class="line"></span><br><span class="line">class Page extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123; showWarning: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">      showWarning: !state.showWarning</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const showWarning &#x3D; this.state.showWarning;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Warning warn&#x3D;&#123;showWarning&#125; &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;&#123;showWarning ? &#39;Hide&#39; : &#39;Show&#39;&#125;&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Page;</span><br></pre></td></tr></table></figure><p><code>src\index.js</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Page from &#39;.&#x2F;components&#x2F;Page&#39;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Page &#x2F;&gt;, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure><blockquote><p>在组件的 <code>render</code> 方法中返回 <code>null</code> 并不会影响组件的生命周期.</p></blockquote><h3 id="列表-和-key"><a href="#列表-和-key" class="headerlink" title="列表 和 key"></a>列表 和 key</h3><p>利用<code>map</code>函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class NumberList extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; numbers &#125; &#x3D; this.props;</span><br><span class="line">    const listItems &#x3D; numbers.map(number &#x3D;&gt; &#123;</span><br><span class="line">      return &lt;li&gt;&#123;number&#125;&lt;&#x2F;li&gt;</span><br><span class="line">    &#125;);</span><br><span class="line">    return &lt;ul&gt;&#123;listItems&#125;&lt;&#x2F;ul&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default NumberList;</span><br></pre></td></tr></table></figure><p>将该组件挂载到<code>root</code>上面,会发现有一个<code>warning</code>:</p><p><img src="http://veng.gitee.io/hexo/2020/03/18/react/assets/1584454829695.png" alt="1584454829695"></p><p>意思是当你创建一个元素时，必须包括一个特殊的 <code>key</code> 属性。</p><p>按照它的警告我们为每个元素加上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const listItems &#x3D; numbers.map(number &#x3D;&gt; &#123;</span><br><span class="line">return &lt;li key&#x3D;&#123;number&#125;&gt;&#123;number&#125;&lt;&#x2F;li&gt;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样警告消除了.</p><p>那么<code>Key</code>的作用是什么呢?</p><h4 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h4><p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。</p><p>一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key.</p><p>数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值.</p><p>当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const todoItems &#x3D; todos.map((todo, index) &#x3D;&gt;</span><br><span class="line">  &#x2F;&#x2F; Only do this if items have no stable IDs</span><br><span class="line">  &lt;li key&#x3D;&#123;index&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。</p><p>如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。</p></blockquote><p><font color="#dd001b">元素的 key 只有放在就近的数组上下文中才有意义。</font></p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function ListItem(props) &#123;</span><br><span class="line">  &#x2F;&#x2F; 正确！这里不需要指定 key：</span><br><span class="line">  return &lt;li&gt;&#123;props.value&#125;&lt;&#x2F;li&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers &#x3D; props.numbers;</span><br><span class="line">  const listItems &#x3D; numbers.map((number) &#x3D;&gt;</span><br><span class="line">    &#x2F;&#x2F; 正确！key 应该在数组的上下文中被指定</span><br><span class="line">    &lt;ListItem key&#x3D;&#123;number.toString()&#125;</span><br><span class="line">              value&#x3D;&#123;number&#125; &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>key</code>是放在<code>ListItem</code>上而不是<code>li</code>上,因为就近数组的上下文在<code>ListItem</code>这里.</p><blockquote><p>一个好的经验法则是：在 <code>map()</code> 方法中的元素需要设置 key 属性。</p></blockquote><p>还有就是对于key属性,它不会传值给组件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const content &#x3D; posts.map((post) &#x3D;&gt;</span><br><span class="line">  &lt;Post</span><br><span class="line">    key&#x3D;&#123;post.id&#125;</span><br><span class="line">    id&#x3D;&#123;post.id&#125;</span><br><span class="line">    title&#x3D;&#123;post.title&#125; &#x2F;&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>Post</code>组件的<code>props</code>读不到<code>key</code>,但是可以读取到<code>props.id</code>和<code>props.title</code>.</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state。</p><p>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 <a href="https://react.docschina.org/docs/react-component.html#setstate" target="_blank" rel="noopener"><code>setState()</code></a>来更新。我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“<strong>受控组件</strong>”。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123; value: &#39;&#39; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      value: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(this.state.value);</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input value&#x3D;&#123;this.state.value&#125; onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;input type&#x3D;&#39;submit&#39; value&#x3D;&#39;提交&#39; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default NameForm;</span><br></pre></td></tr></table></figure><p><img src="http://veng.gitee.io/hexo/2020/03/18/react/assets/sky10.2.gif" alt="图像"></p><p>以上将<code>input</code>的值绑定在了该组件的<code>state</code>.</p><h4 id="处理多个输入"><a href="#处理多个输入" class="headerlink" title="处理多个输入"></a>处理多个输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class Reservation extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      isGoing: true,</span><br><span class="line">      numberOfGuests: 2</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class="line">    const target &#x3D; event.target;</span><br><span class="line">    const value &#x3D; target.type &#x3D;&#x3D;&#x3D; &#39;checkbox&#39; ? target.checked : target.value;</span><br><span class="line">    const name &#x3D; target.name;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          参与:</span><br><span class="line">          &lt;input</span><br><span class="line">            name&#x3D;&quot;isGoing&quot;</span><br><span class="line">            type&#x3D;&quot;checkbox&quot;</span><br><span class="line">            checked&#x3D;&#123;this.state.isGoing&#125;</span><br><span class="line">            onChange&#x3D;&#123;this.handleInputChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          来宾人数:</span><br><span class="line">          &lt;input</span><br><span class="line">            name&#x3D;&quot;numberOfGuests&quot;</span><br><span class="line">            type&#x3D;&quot;number&quot;</span><br><span class="line">            value&#x3D;&#123;this.state.numberOfGuests&#125;</span><br><span class="line">            onChange&#x3D;&#123;this.handleInputChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Reservation;</span><br></pre></td></tr></table></figure><p><img src="http://veng.gitee.io/hexo/2020/03/18/react/assets/sky10.3.gif" alt></p><p>这个例子中,两个<code>input</code>绑定的同一个函数,函数中通过<code>name</code>来获悉是哪个组件,并且<code>name</code>与<code>state</code>里的属性名相同.</p><h3 id="状态的提升"><a href="#状态的提升" class="headerlink" title="状态的提升"></a>状态的提升</h3><p>现在是有这么个需求,有两个输入框,一个输入框是摄氏度,一个是华氏度,只要输入的温度,两个框会自动同步转换,也就是兄弟组件之间怎么传递数据的问题.</p><p>先写温度输入框组件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const scaleNames &#x3D; &#123;</span><br><span class="line">  c: &#39;Celsius&#39;,</span><br><span class="line">  f: &#39;Fahrenheit&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TemperatureInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">    this.state &#x3D; &#123;temperature: &#39;&#39;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature &#x3D; this.state.temperature;</span><br><span class="line">    const scale &#x3D; this.props.scale;</span><br><span class="line">    return (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;&#x2F;legend&gt;</span><br><span class="line">        &lt;input value&#x3D;&#123;temperature&#125;</span><br><span class="line">               onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Calculator extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput scale&#x3D;&quot;c&quot; &#x2F;&gt;</span><br><span class="line">        &lt;TemperatureInput scale&#x3D;&quot;f&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有一个问题,两个温度输入框的温度都保存在自己的<code>state</code>里,两者怎么进行数据的交互?</p><p>解决方案是,将温度的接收提升到父组件,也就是说温度输入框的数据,是由父组件传递过来的<code>props</code>决定.</p><p>温度输入框组件修改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class TemperatureInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature &#x3D; this.props.temperature;</span><br><span class="line">    const scale &#x3D; this.props.scale;</span><br><span class="line">    return (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;&#x2F;legend&gt;</span><br><span class="line">        &lt;input value&#x3D;&#123;temperature&#125;</span><br><span class="line">               onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在输入框的数据由父组件传入所决定,并且<code>onChange</code>绑定调用的是有父组件传递的函数.</p><p>父组件修改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 温度转换的函数</span><br><span class="line">function toCelsius(fahrenheit) &#123;</span><br><span class="line">  return (fahrenheit - 32) * 5 &#x2F; 9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function toFahrenheit(celsius) &#123;</span><br><span class="line">  return (celsius * 9 &#x2F; 5) + 32;</span><br><span class="line">&#125;</span><br><span class="line">function tryConvert(temperature, convert) &#123;</span><br><span class="line">  const input &#x3D; parseFloat(temperature);</span><br><span class="line">  if (Number.isNaN(input)) &#123;</span><br><span class="line">    return &#39;&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  const output &#x3D; convert(input);</span><br><span class="line">  const rounded &#x3D; Math.round(output * 1000) &#x2F; 1000;</span><br><span class="line">  return rounded.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">class Calculator extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleCelsiusChange &#x3D; this.handleCelsiusChange.bind(this);</span><br><span class="line">    this.handleFahrenheitChange &#x3D; this.handleFahrenheitChange.bind(this);</span><br><span class="line">    this.state &#x3D; &#123;temperature: &#39;&#39;, scale: &#39;c&#39;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleCelsiusChange(temperature) &#123;</span><br><span class="line">    this.setState(&#123;scale: &#39;c&#39;, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleFahrenheitChange(temperature) &#123;</span><br><span class="line">    this.setState(&#123;scale: &#39;f&#39;, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const scale &#x3D; this.state.scale;</span><br><span class="line">    const temperature &#x3D; this.state.temperature;</span><br><span class="line">    const celsius &#x3D; scale &#x3D;&#x3D;&#x3D; &#39;f&#39; ? tryConvert(temperature, toCelsius) : temperature;</span><br><span class="line">    const fahrenheit &#x3D; scale &#x3D;&#x3D;&#x3D; &#39;c&#39; ? tryConvert(temperature, toFahrenheit) : temperature;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale&#x3D;&quot;c&quot;</span><br><span class="line">          temperature&#x3D;&#123;celsius&#125;</span><br><span class="line">          onTemperatureChange&#x3D;&#123;this.handleCelsiusChange&#125; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale&#x3D;&quot;f&quot;</span><br><span class="line">          temperature&#x3D;&#123;fahrenheit&#125;</span><br><span class="line">          onTemperatureChange&#x3D;&#123;this.handleFahrenheitChange&#125; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个输入框的值由父组件完全掌控,解决兄弟节点数据问题,可以提升到父组件来解决.</p><blockquote><p>在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠<a href="https://react.docschina.org/docs/state-and-lifecycle.html#the-data-flows-down" target="_blank" rel="noopener">自上而下的数据流</a>，而不是尝试在不同组件间同步 state。</p></blockquote><h3 id="组合和继承"><a href="#组合和继承" class="headerlink" title="组合和继承"></a>组合和继承</h3><p>React 有十分强大的组合模式。我们推荐使用组合而非继承来实现组件间的代码重用。</p><h4 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h4><p>有些组件无法提前知晓它们子组件的具体内容。在 <code>Sidebar</code>（侧边栏）和 <code>Dialog</code>（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。</p><p>我们建议这些组件使用一个特殊的 <code>children</code> prop 来将他们的子组件传递到渲染结果中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function FancyBorder(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&#123;&#39;FancyBorder FancyBorder-&#39; + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这使得别的组件可以通过 JSX 嵌套，将任意组件作为子组件传递给它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color&#x3D;&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className&#x3D;&quot;Dialog-title&quot;&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p className&#x3D;&quot;Dialog-message&quot;&gt;</span><br><span class="line">        Thank you for visiting our spacecraft!</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FancyBorder</code>组件中的内容是通过父组件插进来的,这就是<code>props.children</code>的作用,还是十分的实用,实际上我们也能自定义一个属性通过<code>props</code>传递,当然没问题,但是有<code>children</code>提供了,可以减少代码量.</p><p>但是如果碰到需要补充多个部分内容,显然一个<code>children</code>只能补充一个地方,所以此时我们可以自定义属性传递.</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><blockquote><p>在 Facebook，我们在成百上千个组件中使用 React。我们并没有发现需要使用继承来构建组件层次的情况。</p><p>Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。</p><p>如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;React-快速上手&quot;&gt;&lt;a href=&quot;#React-快速上手&quot; class=&quot;headerlink&quot; title=&quot;React 快速上手&quot;&gt;&lt;/a&gt;React 快速上手&lt;/h2&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;开始一个&lt;code&gt;React&lt;/code&gt;的项目.&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npx create-react-app my-app&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：&lt;code&gt;Node &amp;gt;= 8.10&lt;/code&gt; 和 &lt;code&gt;npm &amp;gt;= 5.6&lt;/code&gt;,&lt;code&gt;npx&lt;/code&gt;是 &lt;a href=&quot;https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;npm 5.2+ 附带的 package 运行工具&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://veng.gitee.io/hexo/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="入门" scheme="http://veng.gitee.io/hexo/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="react" scheme="http://veng.gitee.io/hexo/tags/react/"/>
    
  </entry>
  
</feed>
